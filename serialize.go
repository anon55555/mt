// Code generated by mkserialize.sh; DO NOT EDIT.

package mt

import (
	"bytes"
	"compress/zlib"
	"crypto/sha1"
	"errors"
	"fmt"
	"image/color"
	"io"
	"math"
	"sort"
	"unicode/utf16"
)

func write8(w io.Writer, x uint8) {
	_, err := w.Write([]byte{x})
	chk(err)
}

func write16(w io.Writer, x uint16) {
	buf := make([]byte, 2)
	be.PutUint16(buf, x)
	_, err := w.Write(buf)
	chk(err)
}

func write32(w io.Writer, x uint32) {
	buf := make([]byte, 4)
	be.PutUint32(buf, x)
	_, err := w.Write(buf)
	chk(err)
}

func write64(w io.Writer, x uint64) {
	buf := make([]byte, 8)
	be.PutUint64(buf, x)
	_, err := w.Write(buf)
	chk(err)
}
func readBuf(r io.Reader, n int) []byte {
	buf := make([]byte, n)
	_, err := io.ReadFull(r, buf)
	chk(err)
	return buf
}

func read8(r io.Reader) uint8   { return readBuf(r, 1)[0] }
func read16(r io.Reader) uint16 { return be.Uint16(readBuf(r, 2)) }
func read32(r io.Reader) uint32 { return be.Uint32(readBuf(r, 4)) }
func read64(r io.Reader) uint64 { return be.Uint64(readBuf(r, 8)) }

func (obj *ToSrvNil) serialize(w io.Writer) {
}

func (obj *ToSrvNil) deserialize(r io.Reader) {
}

func (obj *ToSrvInit) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).SerializeVer
		write8(w, uint8(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).SupportedCompression).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.CompressionModes", err))
	}
	{
		x := (*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).MinProtoVer
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).MaxProtoVer
		write16(w, uint16(x))
	}
	if len(([]byte((*(*(struct {
		SerializeVer             uint8
		SupportedCompression     CompressionModes
		MinProtoVer, MaxProtoVer uint16
		PlayerName               string

		//mt:opt
		SendFullItemMeta bool
	}))(obj)).PlayerName))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).PlayerName))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).PlayerName))[:])
		chk(err)
	}
	if err := pcall(func() {
		{
			x := (*(*(struct {
				SerializeVer             uint8
				SupportedCompression     CompressionModes
				MinProtoVer, MaxProtoVer uint16
				PlayerName               string

				//mt:opt
				SendFullItemMeta bool
			}))(obj)).SendFullItemMeta
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
	}); err != nil && err != io.EOF {
		chk(err)
	}
}

func (obj *ToSrvInit) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).SerializeVer
		*p = read8(r)
	}
	if err := pcall(func() {
		((*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).SupportedCompression).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.CompressionModes", err))
	}
	{
		p := &(*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).MinProtoVer
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).MaxProtoVer
		*p = read16(r)
	}
	var local1 []uint8
	var local2 uint16
	{
		p := &local2
		*p = read16(r)
	}
	(local1) = make([]uint8, local2)
	{
		_, err := io.ReadFull(r, (local1)[:])
		chk(err)
	}
	((*(*(struct {
		SerializeVer             uint8
		SupportedCompression     CompressionModes
		MinProtoVer, MaxProtoVer uint16
		PlayerName               string

		//mt:opt
		SendFullItemMeta bool
	}))(obj)).PlayerName) = string(local1)
	if err := pcall(func() {
		{
			p := &(*(*(struct {
				SerializeVer             uint8
				SupportedCompression     CompressionModes
				MinProtoVer, MaxProtoVer uint16
				PlayerName               string

				//mt:opt
				SendFullItemMeta bool
			}))(obj)).SendFullItemMeta
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
	}); err != nil && err != io.EOF {
		chk(err)
	}
}

func (obj *ToSrvInit2) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Lang string
	}))(obj)).Lang))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Lang string
		}))(obj)).Lang))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Lang string
		}))(obj)).Lang))[:])
		chk(err)
	}
}

func (obj *ToSrvInit2) deserialize(r io.Reader) {
	var local3 []uint8
	var local4 uint16
	{
		p := &local4
		*p = read16(r)
	}
	(local3) = make([]uint8, local4)
	{
		_, err := io.ReadFull(r, (local3)[:])
		chk(err)
	}
	((*(*(struct {
		Lang string
	}))(obj)).Lang) = string(local3)
}

func (obj *ToSrvJoinModChan) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Channel string
	}))(obj)).Channel))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
		}))(obj)).Channel))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
		}))(obj)).Channel))[:])
		chk(err)
	}
}

func (obj *ToSrvJoinModChan) deserialize(r io.Reader) {
	var local5 []uint8
	var local6 uint16
	{
		p := &local6
		*p = read16(r)
	}
	(local5) = make([]uint8, local6)
	{
		_, err := io.ReadFull(r, (local5)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
	}))(obj)).Channel) = string(local5)
}

func (obj *ToSrvLeaveModChan) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Channel string
	}))(obj)).Channel))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
		}))(obj)).Channel))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
		}))(obj)).Channel))[:])
		chk(err)
	}
}

func (obj *ToSrvLeaveModChan) deserialize(r io.Reader) {
	var local7 []uint8
	var local8 uint16
	{
		p := &local8
		*p = read16(r)
	}
	(local7) = make([]uint8, local8)
	{
		_, err := io.ReadFull(r, (local7)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
	}))(obj)).Channel) = string(local7)
}

func (obj *ToSrvMsgModChan) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Channel string
		Msg     string
	}))(obj)).Channel))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
			Msg     string
		}))(obj)).Channel))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
			Msg     string
		}))(obj)).Channel))[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		Channel string
		Msg     string
	}))(obj)).Msg))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
			Msg     string
		}))(obj)).Msg))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
			Msg     string
		}))(obj)).Msg))[:])
		chk(err)
	}
}

func (obj *ToSrvMsgModChan) deserialize(r io.Reader) {
	var local9 []uint8
	var local10 uint16
	{
		p := &local10
		*p = read16(r)
	}
	(local9) = make([]uint8, local10)
	{
		_, err := io.ReadFull(r, (local9)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
		Msg     string
	}))(obj)).Channel) = string(local9)
	var local11 []uint8
	var local12 uint16
	{
		p := &local12
		*p = read16(r)
	}
	(local11) = make([]uint8, local12)
	{
		_, err := io.ReadFull(r, (local11)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
		Msg     string
	}))(obj)).Msg) = string(local11)
}

func (obj *ToSrvPlayerPos) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Pos PlayerPos
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.PlayerPos", err))
	}
}

func (obj *ToSrvPlayerPos) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Pos PlayerPos
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.PlayerPos", err))
	}
}

func (obj *ToSrvGotBlks) serialize(w io.Writer) {
	if len(((*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks)) > math.MaxUint8 {
		chk(ErrTooLong)
	}
	{
		x := uint8(len(((*(*(struct {
			//mt:len8
			Blks [][3]int16
		}))(obj)).Blks)))
		write8(w, uint8(x))
	}
	for local13 := range (*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks {
		for local14 := range ((*(*(struct {
			//mt:len8
			Blks [][3]int16
		}))(obj)).Blks)[local13] {
			{
				x := (((*(*(struct {
					//mt:len8
					Blks [][3]int16
				}))(obj)).Blks)[local13])[local14]
				write16(w, uint16(x))
			}
		}
	}
}

func (obj *ToSrvGotBlks) deserialize(r io.Reader) {
	var local15 uint8
	{
		p := &local15
		*p = read8(r)
	}
	((*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks) = make([][3]int16, local15)
	for local16 := range (*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks {
		for local17 := range ((*(*(struct {
			//mt:len8
			Blks [][3]int16
		}))(obj)).Blks)[local16] {
			{
				p := &(((*(*(struct {
					//mt:len8
					Blks [][3]int16
				}))(obj)).Blks)[local16])[local17]
				*p = int16(read16(r))
			}
		}
	}
}

func (obj *ToSrvDeletedBlks) serialize(w io.Writer) {
	if len(((*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks)) > math.MaxUint8 {
		chk(ErrTooLong)
	}
	{
		x := uint8(len(((*(*(struct {
			//mt:len8
			Blks [][3]int16
		}))(obj)).Blks)))
		write8(w, uint8(x))
	}
	for local18 := range (*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks {
		for local19 := range ((*(*(struct {
			//mt:len8
			Blks [][3]int16
		}))(obj)).Blks)[local18] {
			{
				x := (((*(*(struct {
					//mt:len8
					Blks [][3]int16
				}))(obj)).Blks)[local18])[local19]
				write16(w, uint16(x))
			}
		}
	}
}

func (obj *ToSrvDeletedBlks) deserialize(r io.Reader) {
	var local20 uint8
	{
		p := &local20
		*p = read8(r)
	}
	((*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks) = make([][3]int16, local20)
	for local21 := range (*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks {
		for local22 := range ((*(*(struct {
			//mt:len8
			Blks [][3]int16
		}))(obj)).Blks)[local21] {
			{
				p := &(((*(*(struct {
					//mt:len8
					Blks [][3]int16
				}))(obj)).Blks)[local21])[local22]
				*p = int16(read16(r))
			}
		}
	}
}

func (obj *ToSrvInvAction) serialize(w io.Writer) {
	{
		_, err := w.Write(([]byte((*(*(struct {
			//mt:raw
			Action string
		}))(obj)).Action))[:])
		chk(err)
	}
}

func (obj *ToSrvInvAction) deserialize(r io.Reader) {
	var local23 []uint8
	for {
		var local24 uint8
		err := pcall(func() {
			{
				p := &local24
				*p = read8(r)
			}
		})
		if err == io.EOF {
			break
		}
		(local23) = append((local23), local24)
		chk(err)
	}
	((*(*(struct {
		//mt:raw
		Action string
	}))(obj)).Action) = string(local23)
}

func (obj *ToSrvChatMsg) serialize(w io.Writer) {
	if len((utf16.Encode([]rune((*(*(struct {
		//mt:utf16
		Msg string
	}))(obj)).Msg)))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len((utf16.Encode([]rune((*(*(struct {
			//mt:utf16
			Msg string
		}))(obj)).Msg)))))
		write16(w, uint16(x))
	}
	for local25 := range utf16.Encode([]rune((*(*(struct {
		//mt:utf16
		Msg string
	}))(obj)).Msg)) {
		{
			x := (utf16.Encode([]rune((*(*(struct {
				//mt:utf16
				Msg string
			}))(obj)).Msg)))[local25]
			write16(w, uint16(x))
		}
	}
}

func (obj *ToSrvChatMsg) deserialize(r io.Reader) {
	var local26 []uint16
	var local27 uint16
	{
		p := &local27
		*p = read16(r)
	}
	(local26) = make([]uint16, local27)
	for local28 := range local26 {
		{
			p := &(local26)[local28]
			*p = read16(r)
		}
	}
	(*(*(struct {
		//mt:utf16
		Msg string
	}))(obj)).Msg = string(utf16.Decode(local26))
}

func (obj *ToSrvFallDmg) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Amount uint16
		}))(obj)).Amount
		write16(w, uint16(x))
	}
}

func (obj *ToSrvFallDmg) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Amount uint16
		}))(obj)).Amount
		*p = read16(r)
	}
}

func (obj *ToSrvSelectItem) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Slot uint16
		}))(obj)).Slot
		write16(w, uint16(x))
	}
}

func (obj *ToSrvSelectItem) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Slot uint16
		}))(obj)).Slot
		*p = read16(r)
	}
}

func (obj *ToSrvRespawn) serialize(w io.Writer) {
}

func (obj *ToSrvRespawn) deserialize(r io.Reader) {
}

func (obj *ToSrvInteract) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Action   Interaction
			ItemSlot uint16
			//mt:lenhdr 32
			Pointed PointedThing
			//mt:end
			Pos PlayerPos
		}))(obj)).Action).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Interaction", err))
	}
	{
		x := (*(*(struct {
			Action   Interaction
			ItemSlot uint16
			//mt:lenhdr 32
			Pointed PointedThing
			//mt:end
			Pos PlayerPos
		}))(obj)).ItemSlot
		write16(w, uint16(x))
	}
	{
		ow := w
		w := new(bytes.Buffer)
		{
			x := (*(*(struct {
				Action   Interaction
				ItemSlot uint16
				//mt:lenhdr 32
				Pointed PointedThing
				//mt:end
				Pos PlayerPos
			}))(obj)).Pointed
			chk(writePointedThing(w, x))
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint32 {
				chk(ErrTooLong)
			}
			{
				x := uint32(len((buf.Bytes())))
				write32(w, uint32(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Action   Interaction
			ItemSlot uint16
			//mt:lenhdr 32
			Pointed PointedThing
			//mt:end
			Pos PlayerPos
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.PlayerPos", err))
	}
}

func (obj *ToSrvInteract) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Action   Interaction
			ItemSlot uint16
			//mt:lenhdr 32
			Pointed PointedThing
			//mt:end
			Pos PlayerPos
		}))(obj)).Action).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Interaction", err))
	}
	{
		p := &(*(*(struct {
			Action   Interaction
			ItemSlot uint16
			//mt:lenhdr 32
			Pointed PointedThing
			//mt:end
			Pos PlayerPos
		}))(obj)).ItemSlot
		*p = read16(r)
	}
	{
		var n uint32
		{
			p := &n
			*p = read32(r)
		}
		r := &io.LimitedReader{r, int64(n)}
		{
			p := &(*(*(struct {
				Action   Interaction
				ItemSlot uint16
				//mt:lenhdr 32
				Pointed PointedThing
				//mt:end
				Pos PlayerPos
			}))(obj)).Pointed
			{
				var err error
				*p, err = readPointedThing(r)
				chk(err)
			}
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Action   Interaction
			ItemSlot uint16
			//mt:lenhdr 32
			Pointed PointedThing
			//mt:end
			Pos PlayerPos
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.PlayerPos", err))
	}
}

func (obj *ToSrvRemovedSounds) serialize(w io.Writer) {
	if len(((*(*(struct {
		IDs []SoundID
	}))(obj)).IDs)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			IDs []SoundID
		}))(obj)).IDs)))
		write16(w, uint16(x))
	}
	for local29 := range (*(*(struct {
		IDs []SoundID
	}))(obj)).IDs {
		if err := pcall(func() {
			(((*(*(struct {
				IDs []SoundID
			}))(obj)).IDs)[local29]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.SoundID", err))
		}
	}
}

func (obj *ToSrvRemovedSounds) deserialize(r io.Reader) {
	var local30 uint16
	{
		p := &local30
		*p = read16(r)
	}
	((*(*(struct {
		IDs []SoundID
	}))(obj)).IDs) = make([]SoundID, local30)
	for local31 := range (*(*(struct {
		IDs []SoundID
	}))(obj)).IDs {
		if err := pcall(func() {
			(((*(*(struct {
				IDs []SoundID
			}))(obj)).IDs)[local31]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.SoundID", err))
		}
	}
}

func (obj *ToSrvNodeMetaFields) serialize(w io.Writer) {
	for local32 := range (*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Pos {
		{
			x := ((*(*(struct {
				Pos      [3]int16
				Formname string
				Fields   []Field
			}))(obj)).Pos)[local32]
			write16(w, uint16(x))
		}
	}
	if len(([]byte((*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Formname))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Pos      [3]int16
			Formname string
			Fields   []Field
		}))(obj)).Formname))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Pos      [3]int16
			Formname string
			Fields   []Field
		}))(obj)).Formname))[:])
		chk(err)
	}
	if len(((*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Fields)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Pos      [3]int16
			Formname string
			Fields   []Field
		}))(obj)).Fields)))
		write16(w, uint16(x))
	}
	for local33 := range (*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Fields {
		if err := pcall(func() {
			(((*(*(struct {
				Pos      [3]int16
				Formname string
				Fields   []Field
			}))(obj)).Fields)[local33]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Field", err))
		}
	}
}

func (obj *ToSrvNodeMetaFields) deserialize(r io.Reader) {
	for local34 := range (*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Pos {
		{
			p := &((*(*(struct {
				Pos      [3]int16
				Formname string
				Fields   []Field
			}))(obj)).Pos)[local34]
			*p = int16(read16(r))
		}
	}
	var local35 []uint8
	var local36 uint16
	{
		p := &local36
		*p = read16(r)
	}
	(local35) = make([]uint8, local36)
	{
		_, err := io.ReadFull(r, (local35)[:])
		chk(err)
	}
	((*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Formname) = string(local35)
	var local37 uint16
	{
		p := &local37
		*p = read16(r)
	}
	((*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Fields) = make([]Field, local37)
	for local38 := range (*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Fields {
		if err := pcall(func() {
			(((*(*(struct {
				Pos      [3]int16
				Formname string
				Fields   []Field
			}))(obj)).Fields)[local38]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Field", err))
		}
	}
}

func (obj *ToSrvInvFields) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Formname string
		Fields   []Field
	}))(obj)).Formname))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Formname string
			Fields   []Field
		}))(obj)).Formname))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Formname string
			Fields   []Field
		}))(obj)).Formname))[:])
		chk(err)
	}
	if len(((*(*(struct {
		Formname string
		Fields   []Field
	}))(obj)).Fields)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Formname string
			Fields   []Field
		}))(obj)).Fields)))
		write16(w, uint16(x))
	}
	for local39 := range (*(*(struct {
		Formname string
		Fields   []Field
	}))(obj)).Fields {
		if err := pcall(func() {
			(((*(*(struct {
				Formname string
				Fields   []Field
			}))(obj)).Fields)[local39]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Field", err))
		}
	}
}

func (obj *ToSrvInvFields) deserialize(r io.Reader) {
	var local40 []uint8
	var local41 uint16
	{
		p := &local41
		*p = read16(r)
	}
	(local40) = make([]uint8, local41)
	{
		_, err := io.ReadFull(r, (local40)[:])
		chk(err)
	}
	((*(*(struct {
		Formname string
		Fields   []Field
	}))(obj)).Formname) = string(local40)
	var local42 uint16
	{
		p := &local42
		*p = read16(r)
	}
	((*(*(struct {
		Formname string
		Fields   []Field
	}))(obj)).Fields) = make([]Field, local42)
	for local43 := range (*(*(struct {
		Formname string
		Fields   []Field
	}))(obj)).Fields {
		if err := pcall(func() {
			(((*(*(struct {
				Formname string
				Fields   []Field
			}))(obj)).Fields)[local43]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Field", err))
		}
	}
}

func (obj *ToSrvReqMedia) serialize(w io.Writer) {
	if len(((*(*(struct {
		Filenames []string
	}))(obj)).Filenames)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Filenames []string
		}))(obj)).Filenames)))
		write16(w, uint16(x))
	}
	for local44 := range (*(*(struct {
		Filenames []string
	}))(obj)).Filenames {
		if len(([]byte(((*(*(struct {
			Filenames []string
		}))(obj)).Filenames)[local44]))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte(((*(*(struct {
				Filenames []string
			}))(obj)).Filenames)[local44]))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte(((*(*(struct {
				Filenames []string
			}))(obj)).Filenames)[local44]))[:])
			chk(err)
		}
	}
}

func (obj *ToSrvReqMedia) deserialize(r io.Reader) {
	var local45 uint16
	{
		p := &local45
		*p = read16(r)
	}
	((*(*(struct {
		Filenames []string
	}))(obj)).Filenames) = make([]string, local45)
	for local46 := range (*(*(struct {
		Filenames []string
	}))(obj)).Filenames {
		var local47 []uint8
		var local48 uint16
		{
			p := &local48
			*p = read16(r)
		}
		(local47) = make([]uint8, local48)
		{
			_, err := io.ReadFull(r, (local47)[:])
			chk(err)
		}
		(((*(*(struct {
			Filenames []string
		}))(obj)).Filenames)[local46]) = string(local47)
	}
}

func (obj *ToSrvCltReady) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Major
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Minor
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Patch
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Reserved
		write8(w, uint8(x))
	}
	if len(([]byte((*(*(struct {
		// Version information.
		Major, Minor, Patch uint8
		Reserved            uint8
		Version             string
		Formspec            uint16
	}))(obj)).Version))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Version))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Version))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Formspec
		write16(w, uint16(x))
	}
}

func (obj *ToSrvCltReady) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Major
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Minor
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Patch
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Reserved
		*p = read8(r)
	}
	var local49 []uint8
	var local50 uint16
	{
		p := &local50
		*p = read16(r)
	}
	(local49) = make([]uint8, local50)
	{
		_, err := io.ReadFull(r, (local49)[:])
		chk(err)
	}
	((*(*(struct {
		// Version information.
		Major, Minor, Patch uint8
		Reserved            uint8
		Version             string
		Formspec            uint16
	}))(obj)).Version) = string(local49)
	{
		p := &(*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Formspec
		*p = read16(r)
	}
}

func (obj *ToSrvFirstSRP) serialize(w io.Writer) {
	if len(((*(*(struct {
		Salt        []byte
		Verifier    []byte
		EmptyPasswd bool
	}))(obj)).Salt)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).Salt)))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(((*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).Salt)[:])
		chk(err)
	}
	if len(((*(*(struct {
		Salt        []byte
		Verifier    []byte
		EmptyPasswd bool
	}))(obj)).Verifier)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).Verifier)))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(((*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).Verifier)[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).EmptyPasswd
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *ToSrvFirstSRP) deserialize(r io.Reader) {
	var local51 uint16
	{
		p := &local51
		*p = read16(r)
	}
	((*(*(struct {
		Salt        []byte
		Verifier    []byte
		EmptyPasswd bool
	}))(obj)).Salt) = make([]byte, local51)
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).Salt)[:])
		chk(err)
	}
	var local52 uint16
	{
		p := &local52
		*p = read16(r)
	}
	((*(*(struct {
		Salt        []byte
		Verifier    []byte
		EmptyPasswd bool
	}))(obj)).Verifier) = make([]byte, local52)
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).Verifier)[:])
		chk(err)
	}
	{
		p := &(*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).EmptyPasswd
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *ToSrvSRPBytesA) serialize(w io.Writer) {
	if len(((*(*(struct {
		A      []byte
		NoSHA1 bool
	}))(obj)).A)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			A      []byte
			NoSHA1 bool
		}))(obj)).A)))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(((*(*(struct {
			A      []byte
			NoSHA1 bool
		}))(obj)).A)[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			A      []byte
			NoSHA1 bool
		}))(obj)).NoSHA1
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *ToSrvSRPBytesA) deserialize(r io.Reader) {
	var local53 uint16
	{
		p := &local53
		*p = read16(r)
	}
	((*(*(struct {
		A      []byte
		NoSHA1 bool
	}))(obj)).A) = make([]byte, local53)
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			A      []byte
			NoSHA1 bool
		}))(obj)).A)[:])
		chk(err)
	}
	{
		p := &(*(*(struct {
			A      []byte
			NoSHA1 bool
		}))(obj)).NoSHA1
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *ToSrvSRPBytesM) serialize(w io.Writer) {
	if len(((*(*(struct {
		M []byte
	}))(obj)).M)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			M []byte
		}))(obj)).M)))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(((*(*(struct {
			M []byte
		}))(obj)).M)[:])
		chk(err)
	}
}

func (obj *ToSrvSRPBytesM) deserialize(r io.Reader) {
	var local54 uint16
	{
		p := &local54
		*p = read16(r)
	}
	((*(*(struct {
		M []byte
	}))(obj)).M) = make([]byte, local54)
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			M []byte
		}))(obj)).M)[:])
		chk(err)
	}
}

func (obj *ToCltHello) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).SerializeVer
		write8(w, uint8(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).Compression).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.CompressionModes", err))
	}
	{
		x := (*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).ProtoVer
		write16(w, uint16(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).AuthMethods).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AuthMethods", err))
	}
	if len(([]byte((*(*(struct {
		SerializeVer uint8
		Compression  CompressionModes
		ProtoVer     uint16
		AuthMethods
		Username string
	}))(obj)).Username))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).Username))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).Username))[:])
		chk(err)
	}
}

func (obj *ToCltHello) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).SerializeVer
		*p = read8(r)
	}
	if err := pcall(func() {
		((*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).Compression).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.CompressionModes", err))
	}
	{
		p := &(*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).ProtoVer
		*p = read16(r)
	}
	if err := pcall(func() {
		((*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).AuthMethods).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AuthMethods", err))
	}
	var local55 []uint8
	var local56 uint16
	{
		p := &local56
		*p = read16(r)
	}
	(local55) = make([]uint8, local56)
	{
		_, err := io.ReadFull(r, (local55)[:])
		chk(err)
	}
	((*(*(struct {
		SerializeVer uint8
		Compression  CompressionModes
		ProtoVer     uint16
		AuthMethods
		Username string
	}))(obj)).Username) = string(local55)
}

func (obj *ToCltAcceptAuth) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).PlayerPos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Pos", err))
	}
	{
		x := (*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).MapSeed
		write64(w, uint64(x))
	}
	{
		x := (*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).SendInterval
		write32(w, math.Float32bits(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).SudoAuthMethods).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AuthMethods", err))
	}
}

func (obj *ToCltAcceptAuth) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).PlayerPos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Pos", err))
	}
	{
		p := &(*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).MapSeed
		*p = read64(r)
	}
	{
		p := &(*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).SendInterval
		*p = math.Float32frombits(read32(r))
	}
	if err := pcall(func() {
		((*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).SudoAuthMethods).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AuthMethods", err))
	}
}

func (obj *ToCltAcceptSudoMode) serialize(w io.Writer) {
}

func (obj *ToCltAcceptSudoMode) deserialize(r io.Reader) {
}

func (obj *ToCltDenySudoMode) serialize(w io.Writer) {
}

func (obj *ToCltDenySudoMode) deserialize(r io.Reader) {
}

func (obj *ToCltDisco) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Reason DiscoReason

			//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
			Custom string

			//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
			Reconnect bool
		}))(obj)).Reason).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.DiscoReason", err))
	}
	if !((*(*(struct {
		Reason DiscoReason

		//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
		Custom string

		//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
		Reconnect bool
	}))(obj)).Reason < maxDiscoReason) {
		chk(errors.New("assertion failed: %s.Reason < maxDiscoReason"))
	}
	if dr := (*(*(struct {
		Reason DiscoReason

		//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
		Custom string

		//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
		Reconnect bool
	}))(obj)).Reason; dr == Custom || dr == Shutdown || dr == Crash {
		if len(([]byte((*(*(struct {
			Reason DiscoReason

			//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
			Custom string

			//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
			Reconnect bool
		}))(obj)).Custom))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Reason DiscoReason

				//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
				Custom string

				//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
				Reconnect bool
			}))(obj)).Custom))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Reason DiscoReason

				//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
				Custom string

				//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
				Reconnect bool
			}))(obj)).Custom))[:])
			chk(err)
		}
	}
	if dr := (*(*(struct {
		Reason DiscoReason

		//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
		Custom string

		//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
		Reconnect bool
	}))(obj)).Reason; dr == Shutdown || dr == Crash {
		{
			x := (*(*(struct {
				Reason DiscoReason

				//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
				Custom string

				//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
				Reconnect bool
			}))(obj)).Reconnect
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
	}
}

func (obj *ToCltDisco) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Reason DiscoReason

			//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
			Custom string

			//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
			Reconnect bool
		}))(obj)).Reason).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.DiscoReason", err))
	}
	if !((*(*(struct {
		Reason DiscoReason

		//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
		Custom string

		//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
		Reconnect bool
	}))(obj)).Reason < maxDiscoReason) {
		chk(errors.New("assertion failed: %s.Reason < maxDiscoReason"))
	}
	if dr := (*(*(struct {
		Reason DiscoReason

		//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
		Custom string

		//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
		Reconnect bool
	}))(obj)).Reason; dr == Custom || dr == Shutdown || dr == Crash {
		var local57 []uint8
		var local58 uint16
		{
			p := &local58
			*p = read16(r)
		}
		(local57) = make([]uint8, local58)
		{
			_, err := io.ReadFull(r, (local57)[:])
			chk(err)
		}
		((*(*(struct {
			Reason DiscoReason

			//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
			Custom string

			//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
			Reconnect bool
		}))(obj)).Custom) = string(local57)
	}
	if dr := (*(*(struct {
		Reason DiscoReason

		//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
		Custom string

		//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
		Reconnect bool
	}))(obj)).Reason; dr == Shutdown || dr == Crash {
		{
			p := &(*(*(struct {
				Reason DiscoReason

				//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
				Custom string

				//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
				Reconnect bool
			}))(obj)).Reconnect
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
	}
}

func (obj *ToCltBlkData) serialize(w io.Writer) {
	for local59 := range (*(*(struct {
		Blkpos [3]int16
		Blk    MapBlk
	}))(obj)).Blkpos {
		{
			x := ((*(*(struct {
				Blkpos [3]int16
				Blk    MapBlk
			}))(obj)).Blkpos)[local59]
			write16(w, uint16(x))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Blkpos [3]int16
			Blk    MapBlk
		}))(obj)).Blk).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.MapBlk", err))
	}
}

func (obj *ToCltBlkData) deserialize(r io.Reader) {
	for local60 := range (*(*(struct {
		Blkpos [3]int16
		Blk    MapBlk
	}))(obj)).Blkpos {
		{
			p := &((*(*(struct {
				Blkpos [3]int16
				Blk    MapBlk
			}))(obj)).Blkpos)[local60]
			*p = int16(read16(r))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Blkpos [3]int16
			Blk    MapBlk
		}))(obj)).Blk).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.MapBlk", err))
	}
}

func (obj *ToCltAddNode) serialize(w io.Writer) {
	for local61 := range (*(*(struct {
		Pos [3]int16
		Node
		KeepMeta bool
	}))(obj)).Pos {
		{
			x := ((*(*(struct {
				Pos [3]int16
				Node
				KeepMeta bool
			}))(obj)).Pos)[local61]
			write16(w, uint16(x))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos [3]int16
			Node
			KeepMeta bool
		}))(obj)).Node).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Node", err))
	}
	{
		x := (*(*(struct {
			Pos [3]int16
			Node
			KeepMeta bool
		}))(obj)).KeepMeta
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *ToCltAddNode) deserialize(r io.Reader) {
	for local62 := range (*(*(struct {
		Pos [3]int16
		Node
		KeepMeta bool
	}))(obj)).Pos {
		{
			p := &((*(*(struct {
				Pos [3]int16
				Node
				KeepMeta bool
			}))(obj)).Pos)[local62]
			*p = int16(read16(r))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos [3]int16
			Node
			KeepMeta bool
		}))(obj)).Node).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Node", err))
	}
	{
		p := &(*(*(struct {
			Pos [3]int16
			Node
			KeepMeta bool
		}))(obj)).KeepMeta
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *ToCltRemoveNode) serialize(w io.Writer) {
	for local63 := range (*(*(struct {
		Pos [3]int16
	}))(obj)).Pos {
		{
			x := ((*(*(struct {
				Pos [3]int16
			}))(obj)).Pos)[local63]
			write16(w, uint16(x))
		}
	}
}

func (obj *ToCltRemoveNode) deserialize(r io.Reader) {
	for local64 := range (*(*(struct {
		Pos [3]int16
	}))(obj)).Pos {
		{
			p := &((*(*(struct {
				Pos [3]int16
			}))(obj)).Pos)[local64]
			*p = int16(read16(r))
		}
	}
}

func (obj *ToCltInv) serialize(w io.Writer) {
	{
		_, err := w.Write(([]byte((*(*(struct {
			//mt:raw
			Inv string
		}))(obj)).Inv))[:])
		chk(err)
	}
}

func (obj *ToCltInv) deserialize(r io.Reader) {
	var local65 []uint8
	for {
		var local66 uint8
		err := pcall(func() {
			{
				p := &local66
				*p = read8(r)
			}
		})
		if err == io.EOF {
			break
		}
		(local65) = append((local65), local66)
		chk(err)
	}
	((*(*(struct {
		//mt:raw
		Inv string
	}))(obj)).Inv) = string(local65)
}

func (obj *ToCltTimeOfDay) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Time  uint16  // %24000
			Speed float32 // Speed times faster than real time
		}))(obj)).Time
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			Time  uint16  // %24000
			Speed float32 // Speed times faster than real time
		}))(obj)).Speed
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltTimeOfDay) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Time  uint16  // %24000
			Speed float32 // Speed times faster than real time
		}))(obj)).Time
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			Time  uint16  // %24000
			Speed float32 // Speed times faster than real time
		}))(obj)).Speed
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltCSMRestrictionFlags) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Flags CSMRestrictionFlags

			// MapRange is the maximum distance from the player CSMs can read the map
			// if Flags&LimitMapRange != 0.
			MapRange uint32
		}))(obj)).Flags).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.CSMRestrictionFlags", err))
	}
	{
		x := (*(*(struct {
			Flags CSMRestrictionFlags

			// MapRange is the maximum distance from the player CSMs can read the map
			// if Flags&LimitMapRange != 0.
			MapRange uint32
		}))(obj)).MapRange
		write32(w, uint32(x))
	}
}

func (obj *ToCltCSMRestrictionFlags) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Flags CSMRestrictionFlags

			// MapRange is the maximum distance from the player CSMs can read the map
			// if Flags&LimitMapRange != 0.
			MapRange uint32
		}))(obj)).Flags).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.CSMRestrictionFlags", err))
	}
	{
		p := &(*(*(struct {
			Flags CSMRestrictionFlags

			// MapRange is the maximum distance from the player CSMs can read the map
			// if Flags&LimitMapRange != 0.
			MapRange uint32
		}))(obj)).MapRange
		*p = read32(r)
	}
}

func (obj *ToCltAddPlayerVel) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Vel Vec
		}))(obj)).Vel).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Vec", err))
	}
}

func (obj *ToCltAddPlayerVel) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Vel Vec
		}))(obj)).Vel).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Vec", err))
	}
}

func (obj *ToCltMediaPush) serialize(w io.Writer) {
	{
		local67 := uint16(sha1.Size)
		{
			x := local67
			write16(w, uint16(x))
		}
	}
	{
		_, err := w.Write(((*(*(struct {
			//mt:const uint16(sha1.Size)
			SHA1        [sha1.Size]byte
			Filename    string
			ShouldCache bool

			//mt:len32
			Data []byte
		}))(obj)).SHA1)[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		//mt:const uint16(sha1.Size)
		SHA1        [sha1.Size]byte
		Filename    string
		ShouldCache bool

		//mt:len32
		Data []byte
	}))(obj)).Filename))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			//mt:const uint16(sha1.Size)
			SHA1        [sha1.Size]byte
			Filename    string
			ShouldCache bool

			//mt:len32
			Data []byte
		}))(obj)).Filename))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			//mt:const uint16(sha1.Size)
			SHA1        [sha1.Size]byte
			Filename    string
			ShouldCache bool

			//mt:len32
			Data []byte
		}))(obj)).Filename))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			//mt:const uint16(sha1.Size)
			SHA1        [sha1.Size]byte
			Filename    string
			ShouldCache bool

			//mt:len32
			Data []byte
		}))(obj)).ShouldCache
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if len(((*(*(struct {
		//mt:const uint16(sha1.Size)
		SHA1        [sha1.Size]byte
		Filename    string
		ShouldCache bool

		//mt:len32
		Data []byte
	}))(obj)).Data)) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(((*(*(struct {
			//mt:const uint16(sha1.Size)
			SHA1        [sha1.Size]byte
			Filename    string
			ShouldCache bool

			//mt:len32
			Data []byte
		}))(obj)).Data)))
		write32(w, uint32(x))
	}
	{
		_, err := w.Write(((*(*(struct {
			//mt:const uint16(sha1.Size)
			SHA1        [sha1.Size]byte
			Filename    string
			ShouldCache bool

			//mt:len32
			Data []byte
		}))(obj)).Data)[:])
		chk(err)
	}
}

func (obj *ToCltMediaPush) deserialize(r io.Reader) {
	{
		var local68 uint16
		{
			p := &local68
			*p = read16(r)
		}
		if local68 != (20) {
			chk(fmt.Errorf("const %v: %v", 20, local68))
		}
	}
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			//mt:const uint16(sha1.Size)
			SHA1        [sha1.Size]byte
			Filename    string
			ShouldCache bool

			//mt:len32
			Data []byte
		}))(obj)).SHA1)[:])
		chk(err)
	}
	var local69 []uint8
	var local70 uint16
	{
		p := &local70
		*p = read16(r)
	}
	(local69) = make([]uint8, local70)
	{
		_, err := io.ReadFull(r, (local69)[:])
		chk(err)
	}
	((*(*(struct {
		//mt:const uint16(sha1.Size)
		SHA1        [sha1.Size]byte
		Filename    string
		ShouldCache bool

		//mt:len32
		Data []byte
	}))(obj)).Filename) = string(local69)
	{
		p := &(*(*(struct {
			//mt:const uint16(sha1.Size)
			SHA1        [sha1.Size]byte
			Filename    string
			ShouldCache bool

			//mt:len32
			Data []byte
		}))(obj)).ShouldCache
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	var local71 uint32
	{
		p := &local71
		*p = read32(r)
	}
	((*(*(struct {
		//mt:const uint16(sha1.Size)
		SHA1        [sha1.Size]byte
		Filename    string
		ShouldCache bool

		//mt:len32
		Data []byte
	}))(obj)).Data) = make([]byte, local71)
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			//mt:const uint16(sha1.Size)
			SHA1        [sha1.Size]byte
			Filename    string
			ShouldCache bool

			//mt:len32
			Data []byte
		}))(obj)).Data)[:])
		chk(err)
	}
}

func (obj *ToCltChatMsg) serialize(w io.Writer) {
	{
		local72 := uint8(1)
		{
			x := local72
			write8(w, uint8(x))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Type ChatMsgType

			//mt:utf16
			Sender, Text string

			Timestamp int64 // Unix time.
		}))(obj)).Type).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.ChatMsgType", err))
	}
	if len((utf16.Encode([]rune((*(*(struct {
		Type ChatMsgType

		//mt:utf16
		Sender, Text string

		Timestamp int64 // Unix time.
	}))(obj)).Sender)))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len((utf16.Encode([]rune((*(*(struct {
			Type ChatMsgType

			//mt:utf16
			Sender, Text string

			Timestamp int64 // Unix time.
		}))(obj)).Sender)))))
		write16(w, uint16(x))
	}
	for local73 := range utf16.Encode([]rune((*(*(struct {
		Type ChatMsgType

		//mt:utf16
		Sender, Text string

		Timestamp int64 // Unix time.
	}))(obj)).Sender)) {
		{
			x := (utf16.Encode([]rune((*(*(struct {
				Type ChatMsgType

				//mt:utf16
				Sender, Text string

				Timestamp int64 // Unix time.
			}))(obj)).Sender)))[local73]
			write16(w, uint16(x))
		}
	}
	if len((utf16.Encode([]rune((*(*(struct {
		Type ChatMsgType

		//mt:utf16
		Sender, Text string

		Timestamp int64 // Unix time.
	}))(obj)).Text)))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len((utf16.Encode([]rune((*(*(struct {
			Type ChatMsgType

			//mt:utf16
			Sender, Text string

			Timestamp int64 // Unix time.
		}))(obj)).Text)))))
		write16(w, uint16(x))
	}
	for local74 := range utf16.Encode([]rune((*(*(struct {
		Type ChatMsgType

		//mt:utf16
		Sender, Text string

		Timestamp int64 // Unix time.
	}))(obj)).Text)) {
		{
			x := (utf16.Encode([]rune((*(*(struct {
				Type ChatMsgType

				//mt:utf16
				Sender, Text string

				Timestamp int64 // Unix time.
			}))(obj)).Text)))[local74]
			write16(w, uint16(x))
		}
	}
	{
		x := (*(*(struct {
			Type ChatMsgType

			//mt:utf16
			Sender, Text string

			Timestamp int64 // Unix time.
		}))(obj)).Timestamp
		write64(w, uint64(x))
	}
}

func (obj *ToCltChatMsg) deserialize(r io.Reader) {
	{
		var local75 uint8
		{
			p := &local75
			*p = read8(r)
		}
		if local75 != (1) {
			chk(fmt.Errorf("const %v: %v", 1, local75))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Type ChatMsgType

			//mt:utf16
			Sender, Text string

			Timestamp int64 // Unix time.
		}))(obj)).Type).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.ChatMsgType", err))
	}
	var local76 []uint16
	var local77 uint16
	{
		p := &local77
		*p = read16(r)
	}
	(local76) = make([]uint16, local77)
	for local78 := range local76 {
		{
			p := &(local76)[local78]
			*p = read16(r)
		}
	}
	(*(*(struct {
		Type ChatMsgType

		//mt:utf16
		Sender, Text string

		Timestamp int64 // Unix time.
	}))(obj)).Sender = string(utf16.Decode(local76))
	var local79 []uint16
	var local80 uint16
	{
		p := &local80
		*p = read16(r)
	}
	(local79) = make([]uint16, local80)
	for local81 := range local79 {
		{
			p := &(local79)[local81]
			*p = read16(r)
		}
	}
	(*(*(struct {
		Type ChatMsgType

		//mt:utf16
		Sender, Text string

		Timestamp int64 // Unix time.
	}))(obj)).Text = string(utf16.Decode(local79))
	{
		p := &(*(*(struct {
			Type ChatMsgType

			//mt:utf16
			Sender, Text string

			Timestamp int64 // Unix time.
		}))(obj)).Timestamp
		*p = int64(read64(r))
	}
}

func (obj *ToCltAORmAdd) serialize(w io.Writer) {
	if len(((*(*(struct {
		Remove []AOID
		Add    []struct {
			ID AOID
			//mt:const genericCAO
			//mt:lenhdr 32
			InitData AOInitData
		}
	}))(obj)).Remove)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Remove []AOID
			Add    []struct {
				ID AOID
				//mt:const genericCAO
				//mt:lenhdr 32
				InitData AOInitData
			}
		}))(obj)).Remove)))
		write16(w, uint16(x))
	}
	for local82 := range (*(*(struct {
		Remove []AOID
		Add    []struct {
			ID AOID
			//mt:const genericCAO
			//mt:lenhdr 32
			InitData AOInitData
		}
	}))(obj)).Remove {
		if err := pcall(func() {
			(((*(*(struct {
				Remove []AOID
				Add    []struct {
					ID AOID
					//mt:const genericCAO
					//mt:lenhdr 32
					InitData AOInitData
				}
			}))(obj)).Remove)[local82]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AOID", err))
		}
	}
	if len(((*(*(struct {
		Remove []AOID
		Add    []struct {
			ID AOID
			//mt:const genericCAO
			//mt:lenhdr 32
			InitData AOInitData
		}
	}))(obj)).Add)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Remove []AOID
			Add    []struct {
				ID AOID
				//mt:const genericCAO
				//mt:lenhdr 32
				InitData AOInitData
			}
		}))(obj)).Add)))
		write16(w, uint16(x))
	}
	for local83 := range (*(*(struct {
		Remove []AOID
		Add    []struct {
			ID AOID
			//mt:const genericCAO
			//mt:lenhdr 32
			InitData AOInitData
		}
	}))(obj)).Add {
		if err := pcall(func() {
			((((*(*(struct {
				Remove []AOID
				Add    []struct {
					ID AOID
					//mt:const genericCAO
					//mt:lenhdr 32
					InitData AOInitData
				}
			}))(obj)).Add)[local83]).ID).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AOID", err))
		}
		{
			local84 := genericCAO
			if err := pcall(func() {
				(local84).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.aoType", err))
			}
		}
		{
			ow := w
			w := new(bytes.Buffer)
			if err := pcall(func() {
				((((*(*(struct {
					Remove []AOID
					Add    []struct {
						ID AOID
						//mt:const genericCAO
						//mt:lenhdr 32
						InitData AOInitData
					}
				}))(obj)).Add)[local83]).InitData).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AOInitData", err))
			}
			{
				buf := w
				w := ow
				if len((buf.Bytes())) > math.MaxUint32 {
					chk(ErrTooLong)
				}
				{
					x := uint32(len((buf.Bytes())))
					write32(w, uint32(x))
				}
				{
					_, err := w.Write((buf.Bytes())[:])
					chk(err)
				}
			}
		}
	}
}

func (obj *ToCltAORmAdd) deserialize(r io.Reader) {
	var local85 uint16
	{
		p := &local85
		*p = read16(r)
	}
	((*(*(struct {
		Remove []AOID
		Add    []struct {
			ID AOID
			//mt:const genericCAO
			//mt:lenhdr 32
			InitData AOInitData
		}
	}))(obj)).Remove) = make([]AOID, local85)
	for local86 := range (*(*(struct {
		Remove []AOID
		Add    []struct {
			ID AOID
			//mt:const genericCAO
			//mt:lenhdr 32
			InitData AOInitData
		}
	}))(obj)).Remove {
		if err := pcall(func() {
			(((*(*(struct {
				Remove []AOID
				Add    []struct {
					ID AOID
					//mt:const genericCAO
					//mt:lenhdr 32
					InitData AOInitData
				}
			}))(obj)).Remove)[local86]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AOID", err))
		}
	}
	var local87 uint16
	{
		p := &local87
		*p = read16(r)
	}
	((*(*(struct {
		Remove []AOID
		Add    []struct {
			ID AOID
			//mt:const genericCAO
			//mt:lenhdr 32
			InitData AOInitData
		}
	}))(obj)).Add) = make([]struct {
		ID       AOID
		InitData AOInitData
	}, local87)
	for local88 := range (*(*(struct {
		Remove []AOID
		Add    []struct {
			ID AOID
			//mt:const genericCAO
			//mt:lenhdr 32
			InitData AOInitData
		}
	}))(obj)).Add {
		if err := pcall(func() {
			((((*(*(struct {
				Remove []AOID
				Add    []struct {
					ID AOID
					//mt:const genericCAO
					//mt:lenhdr 32
					InitData AOInitData
				}
			}))(obj)).Add)[local88]).ID).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AOID", err))
		}
		{
			var local89 aoType
			if err := pcall(func() {
				(local89).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.aoType", err))
			}
			if local89 != (101) {
				chk(fmt.Errorf("const %v: %v", 101, local89))
			}
		}
		{
			var n uint32
			{
				p := &n
				*p = read32(r)
			}
			r := &io.LimitedReader{r, int64(n)}
			if err := pcall(func() {
				((((*(*(struct {
					Remove []AOID
					Add    []struct {
						ID AOID
						//mt:const genericCAO
						//mt:lenhdr 32
						InitData AOInitData
					}
				}))(obj)).Add)[local88]).InitData).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AOInitData", err))
			}
			if r.N > 0 {
				chk(fmt.Errorf("%d bytes of trailing data", r.N))
			}
		}
	}
}

func (obj *ToCltAOMsgs) serialize(w io.Writer) {
	for local90 := range (*(*(struct {
		//mt:raw
		Msgs []IDAOMsg
	}))(obj)).Msgs {
		if err := pcall(func() {
			(((*(*(struct {
				//mt:raw
				Msgs []IDAOMsg
			}))(obj)).Msgs)[local90]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.IDAOMsg", err))
		}
	}
}

func (obj *ToCltAOMsgs) deserialize(r io.Reader) {
	for {
		var local91 IDAOMsg
		err := pcall(func() {
			if err := pcall(func() {
				(local91).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.IDAOMsg", err))
			}
		})
		if err == io.EOF {
			break
		}
		((*(*(struct {
			//mt:raw
			Msgs []IDAOMsg
		}))(obj)).Msgs) = append(((*(*(struct {
			//mt:raw
			Msgs []IDAOMsg
		}))(obj)).Msgs), local91)
		chk(err)
	}
}

func (obj *ToCltHP) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			HP uint16
		}))(obj)).HP
		write16(w, uint16(x))
	}
}

func (obj *ToCltHP) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			HP uint16
		}))(obj)).HP
		*p = read16(r)
	}
}

func (obj *ToCltMovePlayer) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Pitch, Yaw float32
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Pos", err))
	}
	{
		x := (*(*(struct {
			Pos
			Pitch, Yaw float32
		}))(obj)).Pitch
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Pos
			Pitch, Yaw float32
		}))(obj)).Yaw
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltMovePlayer) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Pitch, Yaw float32
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Pos", err))
	}
	{
		p := &(*(*(struct {
			Pos
			Pitch, Yaw float32
		}))(obj)).Pitch
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Pos
			Pitch, Yaw float32
		}))(obj)).Yaw
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltDiscoLegacy) serialize(w io.Writer) {
	if len((utf16.Encode([]rune((*(*(struct {
		//mt:utf16
		Reason string
	}))(obj)).Reason)))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len((utf16.Encode([]rune((*(*(struct {
			//mt:utf16
			Reason string
		}))(obj)).Reason)))))
		write16(w, uint16(x))
	}
	for local92 := range utf16.Encode([]rune((*(*(struct {
		//mt:utf16
		Reason string
	}))(obj)).Reason)) {
		{
			x := (utf16.Encode([]rune((*(*(struct {
				//mt:utf16
				Reason string
			}))(obj)).Reason)))[local92]
			write16(w, uint16(x))
		}
	}
}

func (obj *ToCltDiscoLegacy) deserialize(r io.Reader) {
	var local93 []uint16
	var local94 uint16
	{
		p := &local94
		*p = read16(r)
	}
	(local93) = make([]uint16, local94)
	for local95 := range local93 {
		{
			p := &(local93)[local95]
			*p = read16(r)
		}
	}
	(*(*(struct {
		//mt:utf16
		Reason string
	}))(obj)).Reason = string(utf16.Decode(local93))
}

func (obj *ToCltFOV) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			FOV            float32
			Multiplier     bool
			TransitionTime float32
		}))(obj)).FOV
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			FOV            float32
			Multiplier     bool
			TransitionTime float32
		}))(obj)).Multiplier
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			FOV            float32
			Multiplier     bool
			TransitionTime float32
		}))(obj)).TransitionTime
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltFOV) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			FOV            float32
			Multiplier     bool
			TransitionTime float32
		}))(obj)).FOV
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			FOV            float32
			Multiplier     bool
			TransitionTime float32
		}))(obj)).Multiplier
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			FOV            float32
			Multiplier     bool
			TransitionTime float32
		}))(obj)).TransitionTime
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltDeathScreen) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			PointCam bool
			PointAt  Pos
		}))(obj)).PointCam
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			PointCam bool
			PointAt  Pos
		}))(obj)).PointAt).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Pos", err))
	}
}

func (obj *ToCltDeathScreen) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			PointCam bool
			PointAt  Pos
		}))(obj)).PointCam
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			PointCam bool
			PointAt  Pos
		}))(obj)).PointAt).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Pos", err))
	}
}

func (obj *ToCltMedia) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).N
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).I
		write16(w, uint16(x))
	}
	if len(((*(*(struct {
		// N is the total number of ToCltMedia packets.
		// I is the index of this packet.
		N, I uint16

		//mt:len32
		Files []struct {
			Name string

			//mt:len32
			Data []byte
		}
	}))(obj)).Files)) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(((*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).Files)))
		write32(w, uint32(x))
	}
	for local96 := range (*(*(struct {
		// N is the total number of ToCltMedia packets.
		// I is the index of this packet.
		N, I uint16

		//mt:len32
		Files []struct {
			Name string

			//mt:len32
			Data []byte
		}
	}))(obj)).Files {
		if len(([]byte((((*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).Files)[local96]).Name))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((((*(*(struct {
				// N is the total number of ToCltMedia packets.
				// I is the index of this packet.
				N, I uint16

				//mt:len32
				Files []struct {
					Name string

					//mt:len32
					Data []byte
				}
			}))(obj)).Files)[local96]).Name))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((((*(*(struct {
				// N is the total number of ToCltMedia packets.
				// I is the index of this packet.
				N, I uint16

				//mt:len32
				Files []struct {
					Name string

					//mt:len32
					Data []byte
				}
			}))(obj)).Files)[local96]).Name))[:])
			chk(err)
		}
		if len(((((*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).Files)[local96]).Data)) > math.MaxUint32 {
			chk(ErrTooLong)
		}
		{
			x := uint32(len(((((*(*(struct {
				// N is the total number of ToCltMedia packets.
				// I is the index of this packet.
				N, I uint16

				//mt:len32
				Files []struct {
					Name string

					//mt:len32
					Data []byte
				}
			}))(obj)).Files)[local96]).Data)))
			write32(w, uint32(x))
		}
		{
			_, err := w.Write(((((*(*(struct {
				// N is the total number of ToCltMedia packets.
				// I is the index of this packet.
				N, I uint16

				//mt:len32
				Files []struct {
					Name string

					//mt:len32
					Data []byte
				}
			}))(obj)).Files)[local96]).Data)[:])
			chk(err)
		}
	}
}

func (obj *ToCltMedia) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).N
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).I
		*p = read16(r)
	}
	var local97 uint32
	{
		p := &local97
		*p = read32(r)
	}
	((*(*(struct {
		// N is the total number of ToCltMedia packets.
		// I is the index of this packet.
		N, I uint16

		//mt:len32
		Files []struct {
			Name string

			//mt:len32
			Data []byte
		}
	}))(obj)).Files) = make([]struct {
		Name string
		Data []byte
	}, local97)
	for local98 := range (*(*(struct {
		// N is the total number of ToCltMedia packets.
		// I is the index of this packet.
		N, I uint16

		//mt:len32
		Files []struct {
			Name string

			//mt:len32
			Data []byte
		}
	}))(obj)).Files {
		var local99 []uint8
		var local100 uint16
		{
			p := &local100
			*p = read16(r)
		}
		(local99) = make([]uint8, local100)
		{
			_, err := io.ReadFull(r, (local99)[:])
			chk(err)
		}
		((((*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).Files)[local98]).Name) = string(local99)
		var local101 uint32
		{
			p := &local101
			*p = read32(r)
		}
		((((*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).Files)[local98]).Data) = make([]byte, local101)
		{
			_, err := io.ReadFull(r, ((((*(*(struct {
				// N is the total number of ToCltMedia packets.
				// I is the index of this packet.
				N, I uint16

				//mt:len32
				Files []struct {
					Name string

					//mt:len32
					Data []byte
				}
			}))(obj)).Files)[local98]).Data)[:])
			chk(err)
		}
	}
}

func (obj *ToCltNodeDefs) serialize(w io.Writer) {
	{
		ow := w
		w := new(bytes.Buffer)
		{
			w := zlib.NewWriter(w)
			{
				local102 := uint8(1)
				{
					x := local102
					write8(w, uint8(x))
				}
			}
			{
				x := (*(*(struct {

					// See (de)serialize.fmt.
					Defs []NodeDef
				}))(obj)).Defs
				{ // For ToCltNodeDefs.Defs.
					if len(x) > math.MaxUint16 {
						chk(ErrTooLong)
					}
					write16(w, uint16(len(x)))
					var b bytes.Buffer
					for i := range x {
						x[i].serialize(&b)
					}
					if b.Len() > math.MaxUint32 {
						chk(ErrTooLong)
					}
					write32(w, uint32(b.Len()))
					_, err := b.WriteTo(w)
					chk(err)
				}
			}
			chk(w.Close())
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint32 {
				chk(ErrTooLong)
			}
			{
				x := uint32(len((buf.Bytes())))
				write32(w, uint32(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *ToCltNodeDefs) deserialize(r io.Reader) {
	{
		var n uint32
		{
			p := &n
			*p = read32(r)
		}
		r := &io.LimitedReader{r, int64(n)}
		{
			r, err := zlib.NewReader(byteReader{r})
			chk(err)
			{
				var local103 uint8
				{
					p := &local103
					*p = read8(r)
				}
				if local103 != (1) {
					chk(fmt.Errorf("const %v: %v", 1, local103))
				}
			}
			{
				p := &(*(*(struct {

					// See (de)serialize.fmt.
					Defs []NodeDef
				}))(obj)).Defs
				{ // For ToCltNodeDefs.Defs.
					*p = make([]NodeDef, read16(r))
					r := &io.LimitedReader{r, int64(read32(r))}
					for i := range *p {
						(*p)[i].deserialize(r)
					}
					if r.N > 0 {
						chk(fmt.Errorf("%d bytes of trailing data", r.N))
					}
				}
			}
			chk(r.Close())
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *ToCltAnnounceMedia) serialize(w io.Writer) {
	if len(((*(*(struct {
		Files []struct {
			Name       string
			Base64SHA1 string
		}
		URL string
	}))(obj)).Files)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Files []struct {
				Name       string
				Base64SHA1 string
			}
			URL string
		}))(obj)).Files)))
		write16(w, uint16(x))
	}
	for local104 := range (*(*(struct {
		Files []struct {
			Name       string
			Base64SHA1 string
		}
		URL string
	}))(obj)).Files {
		if len(([]byte((((*(*(struct {
			Files []struct {
				Name       string
				Base64SHA1 string
			}
			URL string
		}))(obj)).Files)[local104]).Name))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((((*(*(struct {
				Files []struct {
					Name       string
					Base64SHA1 string
				}
				URL string
			}))(obj)).Files)[local104]).Name))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((((*(*(struct {
				Files []struct {
					Name       string
					Base64SHA1 string
				}
				URL string
			}))(obj)).Files)[local104]).Name))[:])
			chk(err)
		}
		if len(([]byte((((*(*(struct {
			Files []struct {
				Name       string
				Base64SHA1 string
			}
			URL string
		}))(obj)).Files)[local104]).Base64SHA1))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((((*(*(struct {
				Files []struct {
					Name       string
					Base64SHA1 string
				}
				URL string
			}))(obj)).Files)[local104]).Base64SHA1))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((((*(*(struct {
				Files []struct {
					Name       string
					Base64SHA1 string
				}
				URL string
			}))(obj)).Files)[local104]).Base64SHA1))[:])
			chk(err)
		}
	}
	if len(([]byte((*(*(struct {
		Files []struct {
			Name       string
			Base64SHA1 string
		}
		URL string
	}))(obj)).URL))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Files []struct {
				Name       string
				Base64SHA1 string
			}
			URL string
		}))(obj)).URL))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Files []struct {
				Name       string
				Base64SHA1 string
			}
			URL string
		}))(obj)).URL))[:])
		chk(err)
	}
}

func (obj *ToCltAnnounceMedia) deserialize(r io.Reader) {
	var local105 uint16
	{
		p := &local105
		*p = read16(r)
	}
	((*(*(struct {
		Files []struct {
			Name       string
			Base64SHA1 string
		}
		URL string
	}))(obj)).Files) = make([]struct {
		Name       string
		Base64SHA1 string
	}, local105)
	for local106 := range (*(*(struct {
		Files []struct {
			Name       string
			Base64SHA1 string
		}
		URL string
	}))(obj)).Files {
		var local107 []uint8
		var local108 uint16
		{
			p := &local108
			*p = read16(r)
		}
		(local107) = make([]uint8, local108)
		{
			_, err := io.ReadFull(r, (local107)[:])
			chk(err)
		}
		((((*(*(struct {
			Files []struct {
				Name       string
				Base64SHA1 string
			}
			URL string
		}))(obj)).Files)[local106]).Name) = string(local107)
		var local109 []uint8
		var local110 uint16
		{
			p := &local110
			*p = read16(r)
		}
		(local109) = make([]uint8, local110)
		{
			_, err := io.ReadFull(r, (local109)[:])
			chk(err)
		}
		((((*(*(struct {
			Files []struct {
				Name       string
				Base64SHA1 string
			}
			URL string
		}))(obj)).Files)[local106]).Base64SHA1) = string(local109)
	}
	var local111 []uint8
	var local112 uint16
	{
		p := &local112
		*p = read16(r)
	}
	(local111) = make([]uint8, local112)
	{
		_, err := io.ReadFull(r, (local111)[:])
		chk(err)
	}
	((*(*(struct {
		Files []struct {
			Name       string
			Base64SHA1 string
		}
		URL string
	}))(obj)).URL) = string(local111)
}

func (obj *ToCltItemDefs) serialize(w io.Writer) {
	{
		ow := w
		w := new(bytes.Buffer)
		{
			w := zlib.NewWriter(w)
			{
				local113 := uint8(0)
				{
					x := local113
					write8(w, uint8(x))
				}
			}
			if len(((*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Defs)) > math.MaxUint16 {
				chk(ErrTooLong)
			}
			{
				x := uint16(len(((*(*(struct {
					Defs    []ItemDef
					Aliases []struct{ Alias, Orig string }
				}))(obj)).Defs)))
				write16(w, uint16(x))
			}
			for local114 := range (*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Defs {
				if err := pcall(func() {
					(((*(*(struct {
						Defs    []ItemDef
						Aliases []struct{ Alias, Orig string }
					}))(obj)).Defs)[local114]).serialize(w)
				}); err != nil {
					if err == io.EOF {
						chk(io.EOF)
					}
					chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.ItemDef", err))
				}
			}
			if len(((*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Aliases)) > math.MaxUint16 {
				chk(ErrTooLong)
			}
			{
				x := uint16(len(((*(*(struct {
					Defs    []ItemDef
					Aliases []struct{ Alias, Orig string }
				}))(obj)).Aliases)))
				write16(w, uint16(x))
			}
			for local115 := range (*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Aliases {
				if len(([]byte((((*(*(struct {
					Defs    []ItemDef
					Aliases []struct{ Alias, Orig string }
				}))(obj)).Aliases)[local115]).Alias))) > math.MaxUint16 {
					chk(ErrTooLong)
				}
				{
					x := uint16(len(([]byte((((*(*(struct {
						Defs    []ItemDef
						Aliases []struct{ Alias, Orig string }
					}))(obj)).Aliases)[local115]).Alias))))
					write16(w, uint16(x))
				}
				{
					_, err := w.Write(([]byte((((*(*(struct {
						Defs    []ItemDef
						Aliases []struct{ Alias, Orig string }
					}))(obj)).Aliases)[local115]).Alias))[:])
					chk(err)
				}
				if len(([]byte((((*(*(struct {
					Defs    []ItemDef
					Aliases []struct{ Alias, Orig string }
				}))(obj)).Aliases)[local115]).Orig))) > math.MaxUint16 {
					chk(ErrTooLong)
				}
				{
					x := uint16(len(([]byte((((*(*(struct {
						Defs    []ItemDef
						Aliases []struct{ Alias, Orig string }
					}))(obj)).Aliases)[local115]).Orig))))
					write16(w, uint16(x))
				}
				{
					_, err := w.Write(([]byte((((*(*(struct {
						Defs    []ItemDef
						Aliases []struct{ Alias, Orig string }
					}))(obj)).Aliases)[local115]).Orig))[:])
					chk(err)
				}
			}
			chk(w.Close())
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint32 {
				chk(ErrTooLong)
			}
			{
				x := uint32(len((buf.Bytes())))
				write32(w, uint32(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *ToCltItemDefs) deserialize(r io.Reader) {
	{
		var n uint32
		{
			p := &n
			*p = read32(r)
		}
		r := &io.LimitedReader{r, int64(n)}
		{
			r, err := zlib.NewReader(byteReader{r})
			chk(err)
			{
				var local116 uint8
				{
					p := &local116
					*p = read8(r)
				}
				if local116 != (0) {
					chk(fmt.Errorf("const %v: %v", 0, local116))
				}
			}
			var local117 uint16
			{
				p := &local117
				*p = read16(r)
			}
			((*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Defs) = make([]ItemDef, local117)
			for local118 := range (*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Defs {
				if err := pcall(func() {
					(((*(*(struct {
						Defs    []ItemDef
						Aliases []struct{ Alias, Orig string }
					}))(obj)).Defs)[local118]).deserialize(r)
				}); err != nil {
					if err == io.EOF {
						chk(io.EOF)
					}
					chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.ItemDef", err))
				}
			}
			var local119 uint16
			{
				p := &local119
				*p = read16(r)
			}
			((*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Aliases) = make([]struct {
				Alias string
				Orig  string
			}, local119)
			for local120 := range (*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Aliases {
				var local121 []uint8
				var local122 uint16
				{
					p := &local122
					*p = read16(r)
				}
				(local121) = make([]uint8, local122)
				{
					_, err := io.ReadFull(r, (local121)[:])
					chk(err)
				}
				((((*(*(struct {
					Defs    []ItemDef
					Aliases []struct{ Alias, Orig string }
				}))(obj)).Aliases)[local120]).Alias) = string(local121)
				var local123 []uint8
				var local124 uint16
				{
					p := &local124
					*p = read16(r)
				}
				(local123) = make([]uint8, local124)
				{
					_, err := io.ReadFull(r, (local123)[:])
					chk(err)
				}
				((((*(*(struct {
					Defs    []ItemDef
					Aliases []struct{ Alias, Orig string }
				}))(obj)).Aliases)[local120]).Orig) = string(local123)
			}
			chk(r.Close())
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *ToCltPlaySound) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.SoundID", err))
	}
	if len(([]byte((*(*(struct {
		ID      SoundID
		Name    string
		Gain    float32
		SrcType SoundSrcType
		Pos
		SrcAOID   AOID
		Loop      bool
		Fade      float32
		Pitch     float32
		Ephemeral bool
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Name))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Gain
		write32(w, math.Float32bits(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).SrcType).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.SoundSrcType", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Pos", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).SrcAOID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AOID", err))
	}
	{
		x := (*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Loop
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Fade
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Pitch
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Ephemeral
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *ToCltPlaySound) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.SoundID", err))
	}
	var local125 []uint8
	var local126 uint16
	{
		p := &local126
		*p = read16(r)
	}
	(local125) = make([]uint8, local126)
	{
		_, err := io.ReadFull(r, (local125)[:])
		chk(err)
	}
	((*(*(struct {
		ID      SoundID
		Name    string
		Gain    float32
		SrcType SoundSrcType
		Pos
		SrcAOID   AOID
		Loop      bool
		Fade      float32
		Pitch     float32
		Ephemeral bool
	}))(obj)).Name) = string(local125)
	{
		p := &(*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Gain
		*p = math.Float32frombits(read32(r))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).SrcType).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.SoundSrcType", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Pos", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).SrcAOID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AOID", err))
	}
	{
		p := &(*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Loop
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Fade
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Pitch
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Ephemeral
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *ToCltStopSound) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID SoundID
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.SoundID", err))
	}
}

func (obj *ToCltStopSound) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID SoundID
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.SoundID", err))
	}
}

func (obj *ToCltPrivs) serialize(w io.Writer) {
	if len(((*(*(struct {
		Privs []string
	}))(obj)).Privs)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Privs []string
		}))(obj)).Privs)))
		write16(w, uint16(x))
	}
	for local127 := range (*(*(struct {
		Privs []string
	}))(obj)).Privs {
		if len(([]byte(((*(*(struct {
			Privs []string
		}))(obj)).Privs)[local127]))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte(((*(*(struct {
				Privs []string
			}))(obj)).Privs)[local127]))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte(((*(*(struct {
				Privs []string
			}))(obj)).Privs)[local127]))[:])
			chk(err)
		}
	}
}

func (obj *ToCltPrivs) deserialize(r io.Reader) {
	var local128 uint16
	{
		p := &local128
		*p = read16(r)
	}
	((*(*(struct {
		Privs []string
	}))(obj)).Privs) = make([]string, local128)
	for local129 := range (*(*(struct {
		Privs []string
	}))(obj)).Privs {
		var local130 []uint8
		var local131 uint16
		{
			p := &local131
			*p = read16(r)
		}
		(local130) = make([]uint8, local131)
		{
			_, err := io.ReadFull(r, (local130)[:])
			chk(err)
		}
		(((*(*(struct {
			Privs []string
		}))(obj)).Privs)[local129]) = string(local130)
	}
}

func (obj *ToCltInvFormspec) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		//mt:len32
		Formspec string
	}))(obj)).Formspec))) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(([]byte((*(*(struct {
			//mt:len32
			Formspec string
		}))(obj)).Formspec))))
		write32(w, uint32(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			//mt:len32
			Formspec string
		}))(obj)).Formspec))[:])
		chk(err)
	}
}

func (obj *ToCltInvFormspec) deserialize(r io.Reader) {
	var local132 []uint8
	var local133 uint32
	{
		p := &local133
		*p = read32(r)
	}
	(local132) = make([]uint8, local133)
	{
		_, err := io.ReadFull(r, (local132)[:])
		chk(err)
	}
	((*(*(struct {
		//mt:len32
		Formspec string
	}))(obj)).Formspec) = string(local132)
}

func (obj *ToCltDetachedInv) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Name string
		Keep bool
		Len  uint16 // deprecated

		//mt:raw
		Inv string
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Name))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Keep
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Len
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Inv))[:])
		chk(err)
	}
}

func (obj *ToCltDetachedInv) deserialize(r io.Reader) {
	var local134 []uint8
	var local135 uint16
	{
		p := &local135
		*p = read16(r)
	}
	(local134) = make([]uint8, local135)
	{
		_, err := io.ReadFull(r, (local134)[:])
		chk(err)
	}
	((*(*(struct {
		Name string
		Keep bool
		Len  uint16 // deprecated

		//mt:raw
		Inv string
	}))(obj)).Name) = string(local134)
	{
		p := &(*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Keep
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Len
		*p = read16(r)
	}
	var local136 []uint8
	for {
		var local137 uint8
		err := pcall(func() {
			{
				p := &local137
				*p = read8(r)
			}
		})
		if err == io.EOF {
			break
		}
		(local136) = append((local136), local137)
		chk(err)
	}
	((*(*(struct {
		Name string
		Keep bool
		Len  uint16 // deprecated

		//mt:raw
		Inv string
	}))(obj)).Inv) = string(local136)
}

func (obj *ToCltShowFormspec) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		//mt:len32
		Formspec string

		Formname string
	}))(obj)).Formspec))) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(([]byte((*(*(struct {
			//mt:len32
			Formspec string

			Formname string
		}))(obj)).Formspec))))
		write32(w, uint32(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			//mt:len32
			Formspec string

			Formname string
		}))(obj)).Formspec))[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		//mt:len32
		Formspec string

		Formname string
	}))(obj)).Formname))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			//mt:len32
			Formspec string

			Formname string
		}))(obj)).Formname))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			//mt:len32
			Formspec string

			Formname string
		}))(obj)).Formname))[:])
		chk(err)
	}
}

func (obj *ToCltShowFormspec) deserialize(r io.Reader) {
	var local138 []uint8
	var local139 uint32
	{
		p := &local139
		*p = read32(r)
	}
	(local138) = make([]uint8, local139)
	{
		_, err := io.ReadFull(r, (local138)[:])
		chk(err)
	}
	((*(*(struct {
		//mt:len32
		Formspec string

		Formname string
	}))(obj)).Formspec) = string(local138)
	var local140 []uint8
	var local141 uint16
	{
		p := &local141
		*p = read16(r)
	}
	(local140) = make([]uint8, local141)
	{
		_, err := io.ReadFull(r, (local140)[:])
		chk(err)
	}
	((*(*(struct {
		//mt:len32
		Formspec string

		Formname string
	}))(obj)).Formname) = string(local140)
}

func (obj *ToCltMovement) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).DefaultAccel
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).AirAccel
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).FastAccel
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).WalkSpeed
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).CrouchSpeed
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).FastSpeed
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).ClimbSpeed
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).JumpSpeed
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Fluidity
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Smoothing
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Sink
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Gravity
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltMovement) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).DefaultAccel
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).AirAccel
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).FastAccel
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).WalkSpeed
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).CrouchSpeed
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).FastSpeed
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).ClimbSpeed
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).JumpSpeed
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Fluidity
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Smoothing
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Sink
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Gravity
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltSpawnParticle) serialize(w io.Writer) {
	for local142 := range (*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
	}))(obj)).Pos {
		{
			x := ((*(*(struct {
				Pos, Vel, Acc  [3]float32
				ExpirationTime float32 // in seconds.
				Size           float32
				Collide        bool

				//mt:len32
				Texture

				Vertical    bool
				CollisionRm bool
				AnimParams  TileAnim
				Glow        uint8
				AOCollision bool
				NodeParam0  Content
				NodeParam2  uint8
				NodeTile    uint8
			}))(obj)).Pos)[local142]
			write32(w, math.Float32bits(x))
		}
	}
	for local143 := range (*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
	}))(obj)).Vel {
		{
			x := ((*(*(struct {
				Pos, Vel, Acc  [3]float32
				ExpirationTime float32 // in seconds.
				Size           float32
				Collide        bool

				//mt:len32
				Texture

				Vertical    bool
				CollisionRm bool
				AnimParams  TileAnim
				Glow        uint8
				AOCollision bool
				NodeParam0  Content
				NodeParam2  uint8
				NodeTile    uint8
			}))(obj)).Vel)[local143]
			write32(w, math.Float32bits(x))
		}
	}
	for local144 := range (*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
	}))(obj)).Acc {
		{
			x := ((*(*(struct {
				Pos, Vel, Acc  [3]float32
				ExpirationTime float32 // in seconds.
				Size           float32
				Collide        bool

				//mt:len32
				Texture

				Vertical    bool
				CollisionRm bool
				AnimParams  TileAnim
				Glow        uint8
				AOCollision bool
				NodeParam0  Content
				NodeParam2  uint8
				NodeTile    uint8
			}))(obj)).Acc)[local144]
			write32(w, math.Float32bits(x))
		}
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).ExpirationTime
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Size
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Collide
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if len(([]byte(*(*string)(&((*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
	}))(obj)).Texture))))) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(([]byte(*(*string)(&((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Texture))))))
		write32(w, uint32(x))
	}
	{
		_, err := w.Write(([]byte(*(*string)(&((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Texture))))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Vertical
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).CollisionRm
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).AnimParams).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.TileAnim", err))
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Glow
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).AOCollision
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).NodeParam0).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Content", err))
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).NodeParam2
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).NodeTile
		write8(w, uint8(x))
	}
}

func (obj *ToCltSpawnParticle) deserialize(r io.Reader) {
	for local145 := range (*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
	}))(obj)).Pos {
		{
			p := &((*(*(struct {
				Pos, Vel, Acc  [3]float32
				ExpirationTime float32 // in seconds.
				Size           float32
				Collide        bool

				//mt:len32
				Texture

				Vertical    bool
				CollisionRm bool
				AnimParams  TileAnim
				Glow        uint8
				AOCollision bool
				NodeParam0  Content
				NodeParam2  uint8
				NodeTile    uint8
			}))(obj)).Pos)[local145]
			*p = math.Float32frombits(read32(r))
		}
	}
	for local146 := range (*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
	}))(obj)).Vel {
		{
			p := &((*(*(struct {
				Pos, Vel, Acc  [3]float32
				ExpirationTime float32 // in seconds.
				Size           float32
				Collide        bool

				//mt:len32
				Texture

				Vertical    bool
				CollisionRm bool
				AnimParams  TileAnim
				Glow        uint8
				AOCollision bool
				NodeParam0  Content
				NodeParam2  uint8
				NodeTile    uint8
			}))(obj)).Vel)[local146]
			*p = math.Float32frombits(read32(r))
		}
	}
	for local147 := range (*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
	}))(obj)).Acc {
		{
			p := &((*(*(struct {
				Pos, Vel, Acc  [3]float32
				ExpirationTime float32 // in seconds.
				Size           float32
				Collide        bool

				//mt:len32
				Texture

				Vertical    bool
				CollisionRm bool
				AnimParams  TileAnim
				Glow        uint8
				AOCollision bool
				NodeParam0  Content
				NodeParam2  uint8
				NodeTile    uint8
			}))(obj)).Acc)[local147]
			*p = math.Float32frombits(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).ExpirationTime
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Size
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Collide
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	var local148 []uint8
	var local149 uint32
	{
		p := &local149
		*p = read32(r)
	}
	(local148) = make([]uint8, local149)
	{
		_, err := io.ReadFull(r, (local148)[:])
		chk(err)
	}
	(*(*string)(&((*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
	}))(obj)).Texture))) = string(local148)
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Vertical
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).CollisionRm
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).AnimParams).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.TileAnim", err))
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Glow
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).AOCollision
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).NodeParam0).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Content", err))
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).NodeParam2
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).NodeTile
		*p = read8(r)
	}
}

func (obj *ToCltAddParticleSpawner) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Amount
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Duration
		write32(w, math.Float32bits(x))
	}
	for local150 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).Pos {
		for local151 := range ((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Pos)[local150] {
			{
				x := (((*(*(struct {
					Amount         uint16
					Duration       float32
					Pos, Vel, Acc  [2][3]float32
					ExpirationTime [2]float32 // in seconds.
					Size           [2]float32
					Collide        bool

					//mt:len32
					Texture

					ID           ParticleSpawnerID
					Vertical     bool
					CollisionRm  bool
					AttachedAOID AOID
					AnimParams   TileAnim
					Glow         uint8
					AOCollision  bool
					NodeParam0   Content
					NodeParam2   uint8
					NodeTile     uint8
				}))(obj)).Pos)[local150])[local151]
				write32(w, math.Float32bits(x))
			}
		}
	}
	for local152 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).Vel {
		for local153 := range ((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Vel)[local152] {
			{
				x := (((*(*(struct {
					Amount         uint16
					Duration       float32
					Pos, Vel, Acc  [2][3]float32
					ExpirationTime [2]float32 // in seconds.
					Size           [2]float32
					Collide        bool

					//mt:len32
					Texture

					ID           ParticleSpawnerID
					Vertical     bool
					CollisionRm  bool
					AttachedAOID AOID
					AnimParams   TileAnim
					Glow         uint8
					AOCollision  bool
					NodeParam0   Content
					NodeParam2   uint8
					NodeTile     uint8
				}))(obj)).Vel)[local152])[local153]
				write32(w, math.Float32bits(x))
			}
		}
	}
	for local154 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).Acc {
		for local155 := range ((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Acc)[local154] {
			{
				x := (((*(*(struct {
					Amount         uint16
					Duration       float32
					Pos, Vel, Acc  [2][3]float32
					ExpirationTime [2]float32 // in seconds.
					Size           [2]float32
					Collide        bool

					//mt:len32
					Texture

					ID           ParticleSpawnerID
					Vertical     bool
					CollisionRm  bool
					AttachedAOID AOID
					AnimParams   TileAnim
					Glow         uint8
					AOCollision  bool
					NodeParam0   Content
					NodeParam2   uint8
					NodeTile     uint8
				}))(obj)).Acc)[local154])[local155]
				write32(w, math.Float32bits(x))
			}
		}
	}
	for local156 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).ExpirationTime {
		{
			x := ((*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  [2][3]float32
				ExpirationTime [2]float32 // in seconds.
				Size           [2]float32
				Collide        bool

				//mt:len32
				Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool
				NodeParam0   Content
				NodeParam2   uint8
				NodeTile     uint8
			}))(obj)).ExpirationTime)[local156]
			write32(w, math.Float32bits(x))
		}
	}
	for local157 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).Size {
		{
			x := ((*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  [2][3]float32
				ExpirationTime [2]float32 // in seconds.
				Size           [2]float32
				Collide        bool

				//mt:len32
				Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool
				NodeParam0   Content
				NodeParam2   uint8
				NodeTile     uint8
			}))(obj)).Size)[local157]
			write32(w, math.Float32bits(x))
		}
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Collide
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if len(([]byte(*(*string)(&((*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).Texture))))) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(([]byte(*(*string)(&((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Texture))))))
		write32(w, uint32(x))
	}
	{
		_, err := w.Write(([]byte(*(*string)(&((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Texture))))[:])
		chk(err)
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.ParticleSpawnerID", err))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Vertical
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).CollisionRm
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).AttachedAOID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AOID", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).AnimParams).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.TileAnim", err))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Glow
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).AOCollision
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).NodeParam0).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Content", err))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).NodeParam2
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).NodeTile
		write8(w, uint8(x))
	}
}

func (obj *ToCltAddParticleSpawner) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Amount
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Duration
		*p = math.Float32frombits(read32(r))
	}
	for local158 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).Pos {
		for local159 := range ((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Pos)[local158] {
			{
				p := &(((*(*(struct {
					Amount         uint16
					Duration       float32
					Pos, Vel, Acc  [2][3]float32
					ExpirationTime [2]float32 // in seconds.
					Size           [2]float32
					Collide        bool

					//mt:len32
					Texture

					ID           ParticleSpawnerID
					Vertical     bool
					CollisionRm  bool
					AttachedAOID AOID
					AnimParams   TileAnim
					Glow         uint8
					AOCollision  bool
					NodeParam0   Content
					NodeParam2   uint8
					NodeTile     uint8
				}))(obj)).Pos)[local158])[local159]
				*p = math.Float32frombits(read32(r))
			}
		}
	}
	for local160 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).Vel {
		for local161 := range ((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Vel)[local160] {
			{
				p := &(((*(*(struct {
					Amount         uint16
					Duration       float32
					Pos, Vel, Acc  [2][3]float32
					ExpirationTime [2]float32 // in seconds.
					Size           [2]float32
					Collide        bool

					//mt:len32
					Texture

					ID           ParticleSpawnerID
					Vertical     bool
					CollisionRm  bool
					AttachedAOID AOID
					AnimParams   TileAnim
					Glow         uint8
					AOCollision  bool
					NodeParam0   Content
					NodeParam2   uint8
					NodeTile     uint8
				}))(obj)).Vel)[local160])[local161]
				*p = math.Float32frombits(read32(r))
			}
		}
	}
	for local162 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).Acc {
		for local163 := range ((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Acc)[local162] {
			{
				p := &(((*(*(struct {
					Amount         uint16
					Duration       float32
					Pos, Vel, Acc  [2][3]float32
					ExpirationTime [2]float32 // in seconds.
					Size           [2]float32
					Collide        bool

					//mt:len32
					Texture

					ID           ParticleSpawnerID
					Vertical     bool
					CollisionRm  bool
					AttachedAOID AOID
					AnimParams   TileAnim
					Glow         uint8
					AOCollision  bool
					NodeParam0   Content
					NodeParam2   uint8
					NodeTile     uint8
				}))(obj)).Acc)[local162])[local163]
				*p = math.Float32frombits(read32(r))
			}
		}
	}
	for local164 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).ExpirationTime {
		{
			p := &((*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  [2][3]float32
				ExpirationTime [2]float32 // in seconds.
				Size           [2]float32
				Collide        bool

				//mt:len32
				Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool
				NodeParam0   Content
				NodeParam2   uint8
				NodeTile     uint8
			}))(obj)).ExpirationTime)[local164]
			*p = math.Float32frombits(read32(r))
		}
	}
	for local165 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).Size {
		{
			p := &((*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  [2][3]float32
				ExpirationTime [2]float32 // in seconds.
				Size           [2]float32
				Collide        bool

				//mt:len32
				Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool
				NodeParam0   Content
				NodeParam2   uint8
				NodeTile     uint8
			}))(obj)).Size)[local165]
			*p = math.Float32frombits(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Collide
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	var local166 []uint8
	var local167 uint32
	{
		p := &local167
		*p = read32(r)
	}
	(local166) = make([]uint8, local167)
	{
		_, err := io.ReadFull(r, (local166)[:])
		chk(err)
	}
	(*(*string)(&((*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).Texture))) = string(local166)
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.ParticleSpawnerID", err))
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Vertical
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).CollisionRm
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).AttachedAOID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AOID", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).AnimParams).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.TileAnim", err))
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Glow
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).AOCollision
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).NodeParam0).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Content", err))
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).NodeParam2
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).NodeTile
		*p = read8(r)
	}
}

func (obj *ToCltAddHUD) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID

			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.HUDID", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID

			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
		}))(obj)).Type).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.HUDType", err))
	}
	for local168 := range (*(*(struct {
		ID HUDID

		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
	}))(obj)).Pos {
		{
			x := ((*(*(struct {
				ID HUDID

				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
			}))(obj)).Pos)[local168]
			write32(w, math.Float32bits(x))
		}
	}
	if len(([]byte((*(*(struct {
		ID HUDID

		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			ID HUDID

			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			ID HUDID

			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
		}))(obj)).Name))[:])
		chk(err)
	}
	for local169 := range (*(*(struct {
		ID HUDID

		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
	}))(obj)).Scale {
		{
			x := ((*(*(struct {
				ID HUDID

				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
			}))(obj)).Scale)[local169]
			write32(w, math.Float32bits(x))
		}
	}
	if len(([]byte((*(*(struct {
		ID HUDID

		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
	}))(obj)).Text))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			ID HUDID

			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
		}))(obj)).Text))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			ID HUDID

			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
		}))(obj)).Text))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			ID HUDID

			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
		}))(obj)).Number
		write32(w, uint32(x))
	}
	{
		x := (*(*(struct {
			ID HUDID

			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
		}))(obj)).Item
		write32(w, uint32(x))
	}
	{
		x := (*(*(struct {
			ID HUDID

			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
		}))(obj)).Dir
		write32(w, uint32(x))
	}
	for local170 := range (*(*(struct {
		ID HUDID

		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
	}))(obj)).Align {
		{
			x := ((*(*(struct {
				ID HUDID

				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
			}))(obj)).Align)[local170]
			write32(w, math.Float32bits(x))
		}
	}
	for local171 := range (*(*(struct {
		ID HUDID

		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
	}))(obj)).Offset {
		{
			x := ((*(*(struct {
				ID HUDID

				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
			}))(obj)).Offset)[local171]
			write32(w, math.Float32bits(x))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID

			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
		}))(obj)).WorldPos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Pos", err))
	}
	for local172 := range (*(*(struct {
		ID HUDID

		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
	}))(obj)).Size {
		{
			x := ((*(*(struct {
				ID HUDID

				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
			}))(obj)).Size)[local172]
			write32(w, uint32(x))
		}
	}
	{
		x := (*(*(struct {
			ID HUDID

			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
		}))(obj)).ZIndex
		write16(w, uint16(x))
	}
	if len(([]byte((*(*(struct {
		ID HUDID

		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
	}))(obj)).Text2))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			ID HUDID

			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
		}))(obj)).Text2))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			ID HUDID

			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
		}))(obj)).Text2))[:])
		chk(err)
	}
}

func (obj *ToCltAddHUD) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID

			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.HUDID", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID

			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
		}))(obj)).Type).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.HUDType", err))
	}
	for local173 := range (*(*(struct {
		ID HUDID

		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
	}))(obj)).Pos {
		{
			p := &((*(*(struct {
				ID HUDID

				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
			}))(obj)).Pos)[local173]
			*p = math.Float32frombits(read32(r))
		}
	}
	var local174 []uint8
	var local175 uint16
	{
		p := &local175
		*p = read16(r)
	}
	(local174) = make([]uint8, local175)
	{
		_, err := io.ReadFull(r, (local174)[:])
		chk(err)
	}
	((*(*(struct {
		ID HUDID

		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
	}))(obj)).Name) = string(local174)
	for local176 := range (*(*(struct {
		ID HUDID

		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
	}))(obj)).Scale {
		{
			p := &((*(*(struct {
				ID HUDID

				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
			}))(obj)).Scale)[local176]
			*p = math.Float32frombits(read32(r))
		}
	}
	var local177 []uint8
	var local178 uint16
	{
		p := &local178
		*p = read16(r)
	}
	(local177) = make([]uint8, local178)
	{
		_, err := io.ReadFull(r, (local177)[:])
		chk(err)
	}
	((*(*(struct {
		ID HUDID

		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
	}))(obj)).Text) = string(local177)
	{
		p := &(*(*(struct {
			ID HUDID

			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
		}))(obj)).Number
		*p = read32(r)
	}
	{
		p := &(*(*(struct {
			ID HUDID

			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
		}))(obj)).Item
		*p = read32(r)
	}
	{
		p := &(*(*(struct {
			ID HUDID

			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
		}))(obj)).Dir
		*p = read32(r)
	}
	for local179 := range (*(*(struct {
		ID HUDID

		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
	}))(obj)).Align {
		{
			p := &((*(*(struct {
				ID HUDID

				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
			}))(obj)).Align)[local179]
			*p = math.Float32frombits(read32(r))
		}
	}
	for local180 := range (*(*(struct {
		ID HUDID

		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
	}))(obj)).Offset {
		{
			p := &((*(*(struct {
				ID HUDID

				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
			}))(obj)).Offset)[local180]
			*p = math.Float32frombits(read32(r))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID

			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
		}))(obj)).WorldPos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Pos", err))
	}
	for local181 := range (*(*(struct {
		ID HUDID

		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
	}))(obj)).Size {
		{
			p := &((*(*(struct {
				ID HUDID

				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
			}))(obj)).Size)[local181]
			*p = int32(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			ID HUDID

			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
		}))(obj)).ZIndex
		*p = int16(read16(r))
	}
	var local182 []uint8
	var local183 uint16
	{
		p := &local183
		*p = read16(r)
	}
	(local182) = make([]uint8, local183)
	{
		_, err := io.ReadFull(r, (local182)[:])
		chk(err)
	}
	((*(*(struct {
		ID HUDID

		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
	}))(obj)).Text2) = string(local182)
}

func (obj *ToCltRmHUD) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.HUDID", err))
	}
}

func (obj *ToCltRmHUD) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.HUDID", err))
	}
}

func (obj *ToCltChangeHUD) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex uint32

			//mt:if %s.Field == HUDText2
			Text2 string
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.HUDID", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex uint32

			//mt:if %s.Field == HUDText2
			Text2 string
		}))(obj)).Field).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.HUDField", err))
	}
	if !((*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex uint32

		//mt:if %s.Field == HUDText2
		Text2 string
	}))(obj)).Field < hudMax) {
		chk(errors.New("assertion failed: %s.Field < hudMax"))
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex uint32

		//mt:if %s.Field == HUDText2
		Text2 string
	}))(obj)).Field == HUDPos {
		for local184 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex uint32

			//mt:if %s.Field == HUDText2
			Text2 string
		}))(obj)).Pos {
			{
				x := ((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex uint32

					//mt:if %s.Field == HUDText2
					Text2 string
				}))(obj)).Pos)[local184]
				write32(w, math.Float32bits(x))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex uint32

		//mt:if %s.Field == HUDText2
		Text2 string
	}))(obj)).Field == HUDName {
		if len(([]byte((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex uint32

			//mt:if %s.Field == HUDText2
			Text2 string
		}))(obj)).Name))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex uint32

				//mt:if %s.Field == HUDText2
				Text2 string
			}))(obj)).Name))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex uint32

				//mt:if %s.Field == HUDText2
				Text2 string
			}))(obj)).Name))[:])
			chk(err)
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex uint32

		//mt:if %s.Field == HUDText2
		Text2 string
	}))(obj)).Field == HUDScale {
		for local185 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex uint32

			//mt:if %s.Field == HUDText2
			Text2 string
		}))(obj)).Scale {
			{
				x := ((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex uint32

					//mt:if %s.Field == HUDText2
					Text2 string
				}))(obj)).Scale)[local185]
				write32(w, math.Float32bits(x))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex uint32

		//mt:if %s.Field == HUDText2
		Text2 string
	}))(obj)).Field == HUDText {
		if len(([]byte((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex uint32

			//mt:if %s.Field == HUDText2
			Text2 string
		}))(obj)).Text))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex uint32

				//mt:if %s.Field == HUDText2
				Text2 string
			}))(obj)).Text))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex uint32

				//mt:if %s.Field == HUDText2
				Text2 string
			}))(obj)).Text))[:])
			chk(err)
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex uint32

		//mt:if %s.Field == HUDText2
		Text2 string
	}))(obj)).Field == HUDNumber {
		{
			x := (*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex uint32

				//mt:if %s.Field == HUDText2
				Text2 string
			}))(obj)).Number
			write32(w, uint32(x))
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex uint32

		//mt:if %s.Field == HUDText2
		Text2 string
	}))(obj)).Field == HUDItem {
		{
			x := (*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex uint32

				//mt:if %s.Field == HUDText2
				Text2 string
			}))(obj)).Item
			write32(w, uint32(x))
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex uint32

		//mt:if %s.Field == HUDText2
		Text2 string
	}))(obj)).Field == HUDDir {
		{
			x := (*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex uint32

				//mt:if %s.Field == HUDText2
				Text2 string
			}))(obj)).Dir
			write32(w, uint32(x))
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex uint32

		//mt:if %s.Field == HUDText2
		Text2 string
	}))(obj)).Field == HUDAlign {
		for local186 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex uint32

			//mt:if %s.Field == HUDText2
			Text2 string
		}))(obj)).Align {
			{
				x := ((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex uint32

					//mt:if %s.Field == HUDText2
					Text2 string
				}))(obj)).Align)[local186]
				write32(w, math.Float32bits(x))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex uint32

		//mt:if %s.Field == HUDText2
		Text2 string
	}))(obj)).Field == HUDOffset {
		for local187 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex uint32

			//mt:if %s.Field == HUDText2
			Text2 string
		}))(obj)).Offset {
			{
				x := ((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex uint32

					//mt:if %s.Field == HUDText2
					Text2 string
				}))(obj)).Offset)[local187]
				write32(w, math.Float32bits(x))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex uint32

		//mt:if %s.Field == HUDText2
		Text2 string
	}))(obj)).Field == HUDWorldPos {
		if err := pcall(func() {
			((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex uint32

				//mt:if %s.Field == HUDText2
				Text2 string
			}))(obj)).WorldPos).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Pos", err))
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex uint32

		//mt:if %s.Field == HUDText2
		Text2 string
	}))(obj)).Field == HUDSize {
		for local188 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex uint32

			//mt:if %s.Field == HUDText2
			Text2 string
		}))(obj)).Size {
			{
				x := ((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex uint32

					//mt:if %s.Field == HUDText2
					Text2 string
				}))(obj)).Size)[local188]
				write32(w, uint32(x))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex uint32

		//mt:if %s.Field == HUDText2
		Text2 string
	}))(obj)).Field == HUDZIndex {
		{
			x := (*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex uint32

				//mt:if %s.Field == HUDText2
				Text2 string
			}))(obj)).ZIndex
			write32(w, uint32(x))
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex uint32

		//mt:if %s.Field == HUDText2
		Text2 string
	}))(obj)).Field == HUDText2 {
		if len(([]byte((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex uint32

			//mt:if %s.Field == HUDText2
			Text2 string
		}))(obj)).Text2))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex uint32

				//mt:if %s.Field == HUDText2
				Text2 string
			}))(obj)).Text2))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex uint32

				//mt:if %s.Field == HUDText2
				Text2 string
			}))(obj)).Text2))[:])
			chk(err)
		}
	}
}

func (obj *ToCltChangeHUD) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex uint32

			//mt:if %s.Field == HUDText2
			Text2 string
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.HUDID", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex uint32

			//mt:if %s.Field == HUDText2
			Text2 string
		}))(obj)).Field).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.HUDField", err))
	}
	if !((*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex uint32

		//mt:if %s.Field == HUDText2
		Text2 string
	}))(obj)).Field < hudMax) {
		chk(errors.New("assertion failed: %s.Field < hudMax"))
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex uint32

		//mt:if %s.Field == HUDText2
		Text2 string
	}))(obj)).Field == HUDPos {
		for local189 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex uint32

			//mt:if %s.Field == HUDText2
			Text2 string
		}))(obj)).Pos {
			{
				p := &((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex uint32

					//mt:if %s.Field == HUDText2
					Text2 string
				}))(obj)).Pos)[local189]
				*p = math.Float32frombits(read32(r))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex uint32

		//mt:if %s.Field == HUDText2
		Text2 string
	}))(obj)).Field == HUDName {
		var local190 []uint8
		var local191 uint16
		{
			p := &local191
			*p = read16(r)
		}
		(local190) = make([]uint8, local191)
		{
			_, err := io.ReadFull(r, (local190)[:])
			chk(err)
		}
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex uint32

			//mt:if %s.Field == HUDText2
			Text2 string
		}))(obj)).Name) = string(local190)
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex uint32

		//mt:if %s.Field == HUDText2
		Text2 string
	}))(obj)).Field == HUDScale {
		for local192 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex uint32

			//mt:if %s.Field == HUDText2
			Text2 string
		}))(obj)).Scale {
			{
				p := &((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex uint32

					//mt:if %s.Field == HUDText2
					Text2 string
				}))(obj)).Scale)[local192]
				*p = math.Float32frombits(read32(r))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex uint32

		//mt:if %s.Field == HUDText2
		Text2 string
	}))(obj)).Field == HUDText {
		var local193 []uint8
		var local194 uint16
		{
			p := &local194
			*p = read16(r)
		}
		(local193) = make([]uint8, local194)
		{
			_, err := io.ReadFull(r, (local193)[:])
			chk(err)
		}
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex uint32

			//mt:if %s.Field == HUDText2
			Text2 string
		}))(obj)).Text) = string(local193)
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex uint32

		//mt:if %s.Field == HUDText2
		Text2 string
	}))(obj)).Field == HUDNumber {
		{
			p := &(*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex uint32

				//mt:if %s.Field == HUDText2
				Text2 string
			}))(obj)).Number
			*p = read32(r)
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex uint32

		//mt:if %s.Field == HUDText2
		Text2 string
	}))(obj)).Field == HUDItem {
		{
			p := &(*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex uint32

				//mt:if %s.Field == HUDText2
				Text2 string
			}))(obj)).Item
			*p = read32(r)
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex uint32

		//mt:if %s.Field == HUDText2
		Text2 string
	}))(obj)).Field == HUDDir {
		{
			p := &(*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex uint32

				//mt:if %s.Field == HUDText2
				Text2 string
			}))(obj)).Dir
			*p = read32(r)
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex uint32

		//mt:if %s.Field == HUDText2
		Text2 string
	}))(obj)).Field == HUDAlign {
		for local195 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex uint32

			//mt:if %s.Field == HUDText2
			Text2 string
		}))(obj)).Align {
			{
				p := &((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex uint32

					//mt:if %s.Field == HUDText2
					Text2 string
				}))(obj)).Align)[local195]
				*p = math.Float32frombits(read32(r))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex uint32

		//mt:if %s.Field == HUDText2
		Text2 string
	}))(obj)).Field == HUDOffset {
		for local196 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex uint32

			//mt:if %s.Field == HUDText2
			Text2 string
		}))(obj)).Offset {
			{
				p := &((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex uint32

					//mt:if %s.Field == HUDText2
					Text2 string
				}))(obj)).Offset)[local196]
				*p = math.Float32frombits(read32(r))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex uint32

		//mt:if %s.Field == HUDText2
		Text2 string
	}))(obj)).Field == HUDWorldPos {
		if err := pcall(func() {
			((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex uint32

				//mt:if %s.Field == HUDText2
				Text2 string
			}))(obj)).WorldPos).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Pos", err))
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex uint32

		//mt:if %s.Field == HUDText2
		Text2 string
	}))(obj)).Field == HUDSize {
		for local197 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex uint32

			//mt:if %s.Field == HUDText2
			Text2 string
		}))(obj)).Size {
			{
				p := &((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex uint32

					//mt:if %s.Field == HUDText2
					Text2 string
				}))(obj)).Size)[local197]
				*p = int32(read32(r))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex uint32

		//mt:if %s.Field == HUDText2
		Text2 string
	}))(obj)).Field == HUDZIndex {
		{
			p := &(*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex uint32

				//mt:if %s.Field == HUDText2
				Text2 string
			}))(obj)).ZIndex
			*p = read32(r)
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex uint32

		//mt:if %s.Field == HUDText2
		Text2 string
	}))(obj)).Field == HUDText2 {
		var local198 []uint8
		var local199 uint16
		{
			p := &local199
			*p = read16(r)
		}
		(local198) = make([]uint8, local199)
		{
			_, err := io.ReadFull(r, (local198)[:])
			chk(err)
		}
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex uint32

			//mt:if %s.Field == HUDText2
			Text2 string
		}))(obj)).Text2) = string(local198)
	}
}

func (obj *ToCltHUDFlags) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			// &^= Mask
			// |= Flags
			Flags, Mask HUDFlags
		}))(obj)).Flags).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.HUDFlags", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			// &^= Mask
			// |= Flags
			Flags, Mask HUDFlags
		}))(obj)).Mask).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.HUDFlags", err))
	}
}

func (obj *ToCltHUDFlags) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			// &^= Mask
			// |= Flags
			Flags, Mask HUDFlags
		}))(obj)).Flags).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.HUDFlags", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			// &^= Mask
			// |= Flags
			Flags, Mask HUDFlags
		}))(obj)).Mask).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.HUDFlags", err))
	}
}

func (obj *ToCltSetHotbarParam) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Param HotbarParam

			//mt:if %s.Param == HotbarSize
			//mt:const uint16(4) // Size of Size field.
			Size int32

			//mt:if %s.Param != HotbarSize
			Img Texture
		}))(obj)).Param).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.HotbarParam", err))
	}
	if (*(*(struct {
		Param HotbarParam

		//mt:if %s.Param == HotbarSize
		//mt:const uint16(4) // Size of Size field.
		Size int32

		//mt:if %s.Param != HotbarSize
		Img Texture
	}))(obj)).Param == HotbarSize {
		{
			local200 := uint16(4) // Size of Size field.
			{
				x := local200
				write16(w, uint16(x))
			}
		}
		{
			x := (*(*(struct {
				Param HotbarParam

				//mt:if %s.Param == HotbarSize
				//mt:const uint16(4) // Size of Size field.
				Size int32

				//mt:if %s.Param != HotbarSize
				Img Texture
			}))(obj)).Size
			write32(w, uint32(x))
		}
	}
	if (*(*(struct {
		Param HotbarParam

		//mt:if %s.Param == HotbarSize
		//mt:const uint16(4) // Size of Size field.
		Size int32

		//mt:if %s.Param != HotbarSize
		Img Texture
	}))(obj)).Param != HotbarSize {
		if err := pcall(func() {
			((*(*(struct {
				Param HotbarParam

				//mt:if %s.Param == HotbarSize
				//mt:const uint16(4) // Size of Size field.
				Size int32

				//mt:if %s.Param != HotbarSize
				Img Texture
			}))(obj)).Img).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
		}
	}
}

func (obj *ToCltSetHotbarParam) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Param HotbarParam

			//mt:if %s.Param == HotbarSize
			//mt:const uint16(4) // Size of Size field.
			Size int32

			//mt:if %s.Param != HotbarSize
			Img Texture
		}))(obj)).Param).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.HotbarParam", err))
	}
	if (*(*(struct {
		Param HotbarParam

		//mt:if %s.Param == HotbarSize
		//mt:const uint16(4) // Size of Size field.
		Size int32

		//mt:if %s.Param != HotbarSize
		Img Texture
	}))(obj)).Param == HotbarSize {
		{
			var local201 uint16
			{
				p := &local201
				*p = read16(r)
			}
			if local201 != (4) {
				chk(fmt.Errorf("const %v: %v", 4, local201))
			}
		}
		{
			p := &(*(*(struct {
				Param HotbarParam

				//mt:if %s.Param == HotbarSize
				//mt:const uint16(4) // Size of Size field.
				Size int32

				//mt:if %s.Param != HotbarSize
				Img Texture
			}))(obj)).Size
			*p = int32(read32(r))
		}
	}
	if (*(*(struct {
		Param HotbarParam

		//mt:if %s.Param == HotbarSize
		//mt:const uint16(4) // Size of Size field.
		Size int32

		//mt:if %s.Param != HotbarSize
		Img Texture
	}))(obj)).Param != HotbarSize {
		if err := pcall(func() {
			((*(*(struct {
				Param HotbarParam

				//mt:if %s.Param == HotbarSize
				//mt:const uint16(4) // Size of Size field.
				Size int32

				//mt:if %s.Param != HotbarSize
				Img Texture
			}))(obj)).Img).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
		}
	}
}

func (obj *ToCltBreath) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Breath uint16
		}))(obj)).Breath
		write16(w, uint16(x))
	}
}

func (obj *ToCltBreath) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Breath uint16
		}))(obj)).Breath
		*p = read16(r)
	}
}

func (obj *ToCltSkyParams) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).BgColor
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	if len(([]byte((*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA
	}))(obj)).Type))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).Type))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).Type))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).Clouds
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).SunFogTint
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	{
		x := (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).MoonFogTint
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	if len(([]byte((*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA
	}))(obj)).FogTintType))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).FogTintType))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).FogTintType))[:])
		chk(err)
	}
	if (*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA
	}))(obj)).Type == "skybox" {
		if len(((*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).Textures)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).Textures)))
			write16(w, uint16(x))
		}
		for local202 := range (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).Textures {
			if err := pcall(func() {
				(((*(*(struct {
					BgColor     color.NRGBA
					Type        string
					Clouds      bool
					SunFogTint  color.NRGBA
					MoonFogTint color.NRGBA
					FogTintType string

					//mt:if %s.Type == "skybox"
					Textures []Texture

					//mt:if %s.Type == "regular"
					DaySky, DayHorizon,
					DawnSky, DawnHorizon,
					NightSky, NightHorizon,
					Indoor color.NRGBA
				}))(obj)).Textures)[local202]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
			}
		}
	}
	if (*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA
	}))(obj)).Type == "regular" {
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).DaySky
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).DayHorizon
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).DawnSky
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).DawnHorizon
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).NightSky
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).NightHorizon
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).Indoor
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
	}
}

func (obj *ToCltSkyParams) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).BgColor
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	var local203 []uint8
	var local204 uint16
	{
		p := &local204
		*p = read16(r)
	}
	(local203) = make([]uint8, local204)
	{
		_, err := io.ReadFull(r, (local203)[:])
		chk(err)
	}
	((*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA
	}))(obj)).Type) = string(local203)
	{
		p := &(*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).Clouds
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).SunFogTint
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	{
		p := &(*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).MoonFogTint
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	var local205 []uint8
	var local206 uint16
	{
		p := &local206
		*p = read16(r)
	}
	(local205) = make([]uint8, local206)
	{
		_, err := io.ReadFull(r, (local205)[:])
		chk(err)
	}
	((*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA
	}))(obj)).FogTintType) = string(local205)
	if (*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA
	}))(obj)).Type == "skybox" {
		var local207 uint16
		{
			p := &local207
			*p = read16(r)
		}
		((*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).Textures) = make([]Texture, local207)
		for local208 := range (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).Textures {
			if err := pcall(func() {
				(((*(*(struct {
					BgColor     color.NRGBA
					Type        string
					Clouds      bool
					SunFogTint  color.NRGBA
					MoonFogTint color.NRGBA
					FogTintType string

					//mt:if %s.Type == "skybox"
					Textures []Texture

					//mt:if %s.Type == "regular"
					DaySky, DayHorizon,
					DawnSky, DawnHorizon,
					NightSky, NightHorizon,
					Indoor color.NRGBA
				}))(obj)).Textures)[local208]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
			}
		}
	}
	if (*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA
	}))(obj)).Type == "regular" {
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).DaySky
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).DayHorizon
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).DawnSky
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).DawnHorizon
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).NightSky
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).NightHorizon
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).Indoor
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
	}
}

func (obj *ToCltOverrideDayNightRatio) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Override bool
			Ratio    uint16
		}))(obj)).Override
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Override bool
			Ratio    uint16
		}))(obj)).Ratio
		write16(w, uint16(x))
	}
}

func (obj *ToCltOverrideDayNightRatio) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Override bool
			Ratio    uint16
		}))(obj)).Override
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Override bool
			Ratio    uint16
		}))(obj)).Ratio
		*p = read16(r)
	}
}

func (obj *ToCltLocalPlayerAnim) serialize(w io.Writer) {
	for local209 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).Idle {
		{
			x := ((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).Idle)[local209]
			write32(w, uint32(x))
		}
	}
	for local210 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).Walk {
		{
			x := ((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).Walk)[local210]
			write32(w, uint32(x))
		}
	}
	for local211 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).Dig {
		{
			x := ((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).Dig)[local211]
			write32(w, uint32(x))
		}
	}
	for local212 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).WalkDig {
		{
			x := ((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).WalkDig)[local212]
			write32(w, uint32(x))
		}
	}
	{
		x := (*(*(struct {
			Idle, Walk, Dig, WalkDig [2]int32
			Speed                    float32
		}))(obj)).Speed
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltLocalPlayerAnim) deserialize(r io.Reader) {
	for local213 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).Idle {
		{
			p := &((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).Idle)[local213]
			*p = int32(read32(r))
		}
	}
	for local214 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).Walk {
		{
			p := &((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).Walk)[local214]
			*p = int32(read32(r))
		}
	}
	for local215 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).Dig {
		{
			p := &((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).Dig)[local215]
			*p = int32(read32(r))
		}
	}
	for local216 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).WalkDig {
		{
			p := &((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).WalkDig)[local216]
			*p = int32(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Idle, Walk, Dig, WalkDig [2]int32
			Speed                    float32
		}))(obj)).Speed
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltEyeOffset) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			First, Third Vec
		}))(obj)).First).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Vec", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			First, Third Vec
		}))(obj)).Third).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Vec", err))
	}
}

func (obj *ToCltEyeOffset) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			First, Third Vec
		}))(obj)).First).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Vec", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			First, Third Vec
		}))(obj)).Third).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Vec", err))
	}
}

func (obj *ToCltDelParticleSpawner) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID ParticleSpawnerID
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.ParticleSpawnerID", err))
	}
}

func (obj *ToCltDelParticleSpawner) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID ParticleSpawnerID
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.ParticleSpawnerID", err))
	}
}

func (obj *ToCltCloudParams) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).Density
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).DiffuseColor
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	{
		x := (*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).AmbientColor
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	{
		x := (*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).Height
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).Thickness
		write32(w, math.Float32bits(x))
	}
	for local217 := range (*(*(struct {
		Density      float32
		DiffuseColor color.NRGBA
		AmbientColor color.NRGBA
		Height       float32
		Thickness    float32
		Speed        [2]float32
	}))(obj)).Speed {
		{
			x := ((*(*(struct {
				Density      float32
				DiffuseColor color.NRGBA
				AmbientColor color.NRGBA
				Height       float32
				Thickness    float32
				Speed        [2]float32
			}))(obj)).Speed)[local217]
			write32(w, math.Float32bits(x))
		}
	}
}

func (obj *ToCltCloudParams) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).Density
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).DiffuseColor
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	{
		p := &(*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).AmbientColor
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	{
		p := &(*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).Height
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).Thickness
		*p = math.Float32frombits(read32(r))
	}
	for local218 := range (*(*(struct {
		Density      float32
		DiffuseColor color.NRGBA
		AmbientColor color.NRGBA
		Height       float32
		Thickness    float32
		Speed        [2]float32
	}))(obj)).Speed {
		{
			p := &((*(*(struct {
				Density      float32
				DiffuseColor color.NRGBA
				AmbientColor color.NRGBA
				Height       float32
				Thickness    float32
				Speed        [2]float32
			}))(obj)).Speed)[local218]
			*p = math.Float32frombits(read32(r))
		}
	}
}

func (obj *ToCltFadeSound) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID   SoundID
			Step float32
			Gain float32
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.SoundID", err))
	}
	{
		x := (*(*(struct {
			ID   SoundID
			Step float32
			Gain float32
		}))(obj)).Step
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			ID   SoundID
			Step float32
			Gain float32
		}))(obj)).Gain
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltFadeSound) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID   SoundID
			Step float32
			Gain float32
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.SoundID", err))
	}
	{
		p := &(*(*(struct {
			ID   SoundID
			Step float32
			Gain float32
		}))(obj)).Step
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			ID   SoundID
			Step float32
			Gain float32
		}))(obj)).Gain
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltUpdatePlayerList) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Type    PlayerListUpdateType
			Players []string
		}))(obj)).Type).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.PlayerListUpdateType", err))
	}
	if len(((*(*(struct {
		Type    PlayerListUpdateType
		Players []string
	}))(obj)).Players)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Type    PlayerListUpdateType
			Players []string
		}))(obj)).Players)))
		write16(w, uint16(x))
	}
	for local219 := range (*(*(struct {
		Type    PlayerListUpdateType
		Players []string
	}))(obj)).Players {
		if len(([]byte(((*(*(struct {
			Type    PlayerListUpdateType
			Players []string
		}))(obj)).Players)[local219]))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte(((*(*(struct {
				Type    PlayerListUpdateType
				Players []string
			}))(obj)).Players)[local219]))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte(((*(*(struct {
				Type    PlayerListUpdateType
				Players []string
			}))(obj)).Players)[local219]))[:])
			chk(err)
		}
	}
}

func (obj *ToCltUpdatePlayerList) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Type    PlayerListUpdateType
			Players []string
		}))(obj)).Type).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.PlayerListUpdateType", err))
	}
	var local220 uint16
	{
		p := &local220
		*p = read16(r)
	}
	((*(*(struct {
		Type    PlayerListUpdateType
		Players []string
	}))(obj)).Players) = make([]string, local220)
	for local221 := range (*(*(struct {
		Type    PlayerListUpdateType
		Players []string
	}))(obj)).Players {
		var local222 []uint8
		var local223 uint16
		{
			p := &local223
			*p = read16(r)
		}
		(local222) = make([]uint8, local223)
		{
			_, err := io.ReadFull(r, (local222)[:])
			chk(err)
		}
		(((*(*(struct {
			Type    PlayerListUpdateType
			Players []string
		}))(obj)).Players)[local221]) = string(local222)
	}
}

func (obj *ToCltModChanMsg) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Channel string
		Sender  string
		Msg     string
	}))(obj)).Channel))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
			Sender  string
			Msg     string
		}))(obj)).Channel))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
			Sender  string
			Msg     string
		}))(obj)).Channel))[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		Channel string
		Sender  string
		Msg     string
	}))(obj)).Sender))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
			Sender  string
			Msg     string
		}))(obj)).Sender))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
			Sender  string
			Msg     string
		}))(obj)).Sender))[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		Channel string
		Sender  string
		Msg     string
	}))(obj)).Msg))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
			Sender  string
			Msg     string
		}))(obj)).Msg))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
			Sender  string
			Msg     string
		}))(obj)).Msg))[:])
		chk(err)
	}
}

func (obj *ToCltModChanMsg) deserialize(r io.Reader) {
	var local224 []uint8
	var local225 uint16
	{
		p := &local225
		*p = read16(r)
	}
	(local224) = make([]uint8, local225)
	{
		_, err := io.ReadFull(r, (local224)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
		Sender  string
		Msg     string
	}))(obj)).Channel) = string(local224)
	var local226 []uint8
	var local227 uint16
	{
		p := &local227
		*p = read16(r)
	}
	(local226) = make([]uint8, local227)
	{
		_, err := io.ReadFull(r, (local226)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
		Sender  string
		Msg     string
	}))(obj)).Sender) = string(local226)
	var local228 []uint8
	var local229 uint16
	{
		p := &local229
		*p = read16(r)
	}
	(local228) = make([]uint8, local229)
	{
		_, err := io.ReadFull(r, (local228)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
		Sender  string
		Msg     string
	}))(obj)).Msg) = string(local228)
}

func (obj *ToCltModChanSig) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Signal  ModChanSig
			Channel string
		}))(obj)).Signal).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.ModChanSig", err))
	}
	if len(([]byte((*(*(struct {
		Signal  ModChanSig
		Channel string
	}))(obj)).Channel))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Signal  ModChanSig
			Channel string
		}))(obj)).Channel))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Signal  ModChanSig
			Channel string
		}))(obj)).Channel))[:])
		chk(err)
	}
}

func (obj *ToCltModChanSig) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Signal  ModChanSig
			Channel string
		}))(obj)).Signal).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.ModChanSig", err))
	}
	var local230 []uint8
	var local231 uint16
	{
		p := &local231
		*p = read16(r)
	}
	(local230) = make([]uint8, local231)
	{
		_, err := io.ReadFull(r, (local230)[:])
		chk(err)
	}
	((*(*(struct {
		Signal  ModChanSig
		Channel string
	}))(obj)).Channel) = string(local230)
}

func (obj *ToCltNodeMetasChanged) serialize(w io.Writer) {
	{
		ow := w
		w := new(bytes.Buffer)
		{
			x := (*(*(struct {
				//mt:lenhdr 32
				Changed map[[3]int16]*NodeMeta
			}))(obj)).Changed
			{
				w := zlib.NewWriter(w)
				if x == nil {
					write8(w, 0)
				} else {
					write8(w, 2)
					if len(x) > math.MaxUint16 {
						chk(ErrTooLong)
					}
					write16(w, uint16(len(x)))
					keys := make([][3]int16, 0, len(x))
					for key := range x {
						keys = append(keys, key)
					}
					sort.Slice(keys, func(i, j int) bool {
						p, q := keys[i], keys[j]
						for i := range p {
							switch {
							case p[i] < q[i]:
								return true
							case p[i] > q[i]:
								return false
							}
						}
						return false
					})
					for _, key := range keys {
						for _, n := range key {
							write16(w, uint16(n))
						}
						chk(serialize(w, x[key]))
					}
				}
				chk(w.Close())
			}
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint32 {
				chk(ErrTooLong)
			}
			{
				x := uint32(len((buf.Bytes())))
				write32(w, uint32(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *ToCltNodeMetasChanged) deserialize(r io.Reader) {
	{
		var n uint32
		{
			p := &n
			*p = read32(r)
		}
		r := &io.LimitedReader{r, int64(n)}
		{
			p := &(*(*(struct {
				//mt:lenhdr 32
				Changed map[[3]int16]*NodeMeta
			}))(obj)).Changed
			{
				r, err := zlib.NewReader(byteReader{r})
				chk(err)
				switch ver := read8(r); ver {
				case 0:
					*p = nil
				case 2:
					n := read16(r)
					*p = make(map[[3]int16]*NodeMeta, n)
					for ; n > 0; n-- {
						var pos [3]int16
						for i := range pos {
							pos[i] = int16(read16(r))
						}
						nm := new(NodeMeta)
						chk(deserialize(r, nm))
						(*p)[pos] = nm
					}
				default:
					chk(fmt.Errorf("unsupported nodemetas version: %d", ver))
				}
				chk(r.Close())
			}
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *ToCltSunParams) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Visible
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Texture).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).ToneMap).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Rise).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
	}
	{
		x := (*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Rising
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Size
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltSunParams) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Visible
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Texture).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).ToneMap).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Rise).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
	}
	{
		p := &(*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Rising
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Size
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltMoonParams) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).Visible
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).Texture).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).ToneMap).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
	}
	{
		x := (*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).Size
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltMoonParams) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).Visible
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).Texture).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).ToneMap).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
	}
	{
		p := &(*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).Size
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltStarParams) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Visible bool
			Count   uint32
			Color   color.NRGBA
			Size    float32
		}))(obj)).Visible
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Visible bool
			Count   uint32
			Color   color.NRGBA
			Size    float32
		}))(obj)).Count
		write32(w, uint32(x))
	}
	{
		x := (*(*(struct {
			Visible bool
			Count   uint32
			Color   color.NRGBA
			Size    float32
		}))(obj)).Color
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	{
		x := (*(*(struct {
			Visible bool
			Count   uint32
			Color   color.NRGBA
			Size    float32
		}))(obj)).Size
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltStarParams) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Visible bool
			Count   uint32
			Color   color.NRGBA
			Size    float32
		}))(obj)).Visible
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Visible bool
			Count   uint32
			Color   color.NRGBA
			Size    float32
		}))(obj)).Count
		*p = read32(r)
	}
	{
		p := &(*(*(struct {
			Visible bool
			Count   uint32
			Color   color.NRGBA
			Size    float32
		}))(obj)).Color
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	{
		p := &(*(*(struct {
			Visible bool
			Count   uint32
			Color   color.NRGBA
			Size    float32
		}))(obj)).Size
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltSRPBytesSaltB) serialize(w io.Writer) {
	if len(((*(*(struct {
		Salt, B []byte
	}))(obj)).Salt)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Salt, B []byte
		}))(obj)).Salt)))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(((*(*(struct {
			Salt, B []byte
		}))(obj)).Salt)[:])
		chk(err)
	}
	if len(((*(*(struct {
		Salt, B []byte
	}))(obj)).B)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Salt, B []byte
		}))(obj)).B)))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(((*(*(struct {
			Salt, B []byte
		}))(obj)).B)[:])
		chk(err)
	}
}

func (obj *ToCltSRPBytesSaltB) deserialize(r io.Reader) {
	var local232 uint16
	{
		p := &local232
		*p = read16(r)
	}
	((*(*(struct {
		Salt, B []byte
	}))(obj)).Salt) = make([]byte, local232)
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			Salt, B []byte
		}))(obj)).Salt)[:])
		chk(err)
	}
	var local233 uint16
	{
		p := &local233
		*p = read16(r)
	}
	((*(*(struct {
		Salt, B []byte
	}))(obj)).B) = make([]byte, local233)
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			Salt, B []byte
		}))(obj)).B)[:])
		chk(err)
	}
}

func (obj *ToCltFormspecPrepend) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Prepend string
	}))(obj)).Prepend))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Prepend string
		}))(obj)).Prepend))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Prepend string
		}))(obj)).Prepend))[:])
		chk(err)
	}
}

func (obj *ToCltFormspecPrepend) deserialize(r io.Reader) {
	var local234 []uint8
	var local235 uint16
	{
		p := &local235
		*p = read16(r)
	}
	(local234) = make([]uint8, local235)
	{
		_, err := io.ReadFull(r, (local234)[:])
		chk(err)
	}
	((*(*(struct {
		Prepend string
	}))(obj)).Prepend) = string(local234)
}

func (obj *ToCltMinimapModes) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Current uint16
			Modes   []MinimapMode
		}))(obj)).Current
		write16(w, uint16(x))
	}
	if len(((*(*(struct {
		Current uint16
		Modes   []MinimapMode
	}))(obj)).Modes)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Current uint16
			Modes   []MinimapMode
		}))(obj)).Modes)))
		write16(w, uint16(x))
	}
	for local236 := range (*(*(struct {
		Current uint16
		Modes   []MinimapMode
	}))(obj)).Modes {
		if err := pcall(func() {
			(((*(*(struct {
				Current uint16
				Modes   []MinimapMode
			}))(obj)).Modes)[local236]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.MinimapMode", err))
		}
	}
}

func (obj *ToCltMinimapModes) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Current uint16
			Modes   []MinimapMode
		}))(obj)).Current
		*p = read16(r)
	}
	var local237 uint16
	{
		p := &local237
		*p = read16(r)
	}
	((*(*(struct {
		Current uint16
		Modes   []MinimapMode
	}))(obj)).Modes) = make([]MinimapMode, local237)
	for local238 := range (*(*(struct {
		Current uint16
		Modes   []MinimapMode
	}))(obj)).Modes {
		if err := pcall(func() {
			(((*(*(struct {
				Current uint16
				Modes   []MinimapMode
			}))(obj)).Modes)[local238]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.MinimapMode", err))
		}
	}
}

func (obj *AOCmdProps) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Props AOProps
		}))(obj)).Props).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AOProps", err))
	}
}

func (obj *AOCmdProps) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Props AOProps
		}))(obj)).Props).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AOProps", err))
	}
}

func (obj *AOCmdPos) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Pos AOPos
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AOPos", err))
	}
}

func (obj *AOCmdPos) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Pos AOPos
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AOPos", err))
	}
}

func (obj *AOCmdTextureMod) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Mod Texture // suffix
		}))(obj)).Mod).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
	}
}

func (obj *AOCmdTextureMod) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Mod Texture // suffix
		}))(obj)).Mod).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
	}
}

func (obj *AOCmdSprite) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Sprite AOSprite
		}))(obj)).Sprite).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AOSprite", err))
	}
}

func (obj *AOCmdSprite) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Sprite AOSprite
		}))(obj)).Sprite).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AOSprite", err))
	}
}

func (obj *AOCmdHP) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			HP uint16
		}))(obj)).HP
		write16(w, uint16(x))
	}
}

func (obj *AOCmdHP) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			HP uint16
		}))(obj)).HP
		*p = read16(r)
	}
}

func (obj *AOCmdArmorGroups) serialize(w io.Writer) {
	if len(((*(*(struct {
		Armor []Group
	}))(obj)).Armor)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Armor []Group
		}))(obj)).Armor)))
		write16(w, uint16(x))
	}
	for local239 := range (*(*(struct {
		Armor []Group
	}))(obj)).Armor {
		if err := pcall(func() {
			(((*(*(struct {
				Armor []Group
			}))(obj)).Armor)[local239]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Group", err))
		}
	}
}

func (obj *AOCmdArmorGroups) deserialize(r io.Reader) {
	var local240 uint16
	{
		p := &local240
		*p = read16(r)
	}
	((*(*(struct {
		Armor []Group
	}))(obj)).Armor) = make([]Group, local240)
	for local241 := range (*(*(struct {
		Armor []Group
	}))(obj)).Armor {
		if err := pcall(func() {
			(((*(*(struct {
				Armor []Group
			}))(obj)).Armor)[local241]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Group", err))
		}
	}
}

func (obj *AOCmdAnim) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Anim AOAnim
		}))(obj)).Anim).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AOAnim", err))
	}
}

func (obj *AOCmdAnim) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Anim AOAnim
		}))(obj)).Anim).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AOAnim", err))
	}
}

func (obj *AOCmdBonePos) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Bone string
		Pos  AOBonePos
	}))(obj)).Bone))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Bone string
			Pos  AOBonePos
		}))(obj)).Bone))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Bone string
			Pos  AOBonePos
		}))(obj)).Bone))[:])
		chk(err)
	}
	if err := pcall(func() {
		((*(*(struct {
			Bone string
			Pos  AOBonePos
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AOBonePos", err))
	}
}

func (obj *AOCmdBonePos) deserialize(r io.Reader) {
	var local242 []uint8
	var local243 uint16
	{
		p := &local243
		*p = read16(r)
	}
	(local242) = make([]uint8, local243)
	{
		_, err := io.ReadFull(r, (local242)[:])
		chk(err)
	}
	((*(*(struct {
		Bone string
		Pos  AOBonePos
	}))(obj)).Bone) = string(local242)
	if err := pcall(func() {
		((*(*(struct {
			Bone string
			Pos  AOBonePos
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AOBonePos", err))
	}
}

func (obj *AOCmdAttach) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Attach AOAttach
		}))(obj)).Attach).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AOAttach", err))
	}
}

func (obj *AOCmdAttach) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Attach AOAttach
		}))(obj)).Attach).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AOAttach", err))
	}
}

func (obj *AOCmdPhysOverride) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Phys AOPhysOverride
		}))(obj)).Phys).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AOPhysOverride", err))
	}
}

func (obj *AOCmdPhysOverride) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Phys AOPhysOverride
		}))(obj)).Phys).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AOPhysOverride", err))
	}
}

func (obj *AOCmdSpawnInfant) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AOID", err))
	}
	{
		local244 := genericCAO
		if err := pcall(func() {
			(local244).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.aoType", err))
		}
	}
}

func (obj *AOCmdSpawnInfant) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AOID", err))
	}
	{
		var local245 aoType
		if err := pcall(func() {
			(local245).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.aoType", err))
		}
		if local245 != (101) {
			chk(fmt.Errorf("const %v: %v", 101, local245))
		}
	}
}

func (obj *AOCmdAnimSpeed) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Speed float32
		}))(obj)).Speed
		write32(w, math.Float32bits(x))
	}
}

func (obj *AOCmdAnimSpeed) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Speed float32
		}))(obj)).Speed
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *NodeMeta) serialize(w io.Writer) {
	if len(((*(*(struct {
		//mt:len32
		Fields []NodeMetaField

		Inv Inv
	}))(obj)).Fields)) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(((*(*(struct {
			//mt:len32
			Fields []NodeMetaField

			Inv Inv
		}))(obj)).Fields)))
		write32(w, uint32(x))
	}
	for local246 := range (*(*(struct {
		//mt:len32
		Fields []NodeMetaField

		Inv Inv
	}))(obj)).Fields {
		if err := pcall(func() {
			(((*(*(struct {
				//mt:len32
				Fields []NodeMetaField

				Inv Inv
			}))(obj)).Fields)[local246]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.NodeMetaField", err))
		}
	}
	chk(((*(*(struct {
		//mt:len32
		Fields []NodeMetaField

		Inv Inv
	}))(obj)).Inv).Serialize(w))
}

func (obj *NodeMeta) deserialize(r io.Reader) {
	var local247 uint32
	{
		p := &local247
		*p = read32(r)
	}
	((*(*(struct {
		//mt:len32
		Fields []NodeMetaField

		Inv Inv
	}))(obj)).Fields) = make([]NodeMetaField, local247)
	for local248 := range (*(*(struct {
		//mt:len32
		Fields []NodeMetaField

		Inv Inv
	}))(obj)).Fields {
		if err := pcall(func() {
			(((*(*(struct {
				//mt:len32
				Fields []NodeMetaField

				Inv Inv
			}))(obj)).Fields)[local248]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.NodeMetaField", err))
		}
	}
	chk(((*(*(struct {
		//mt:len32
		Fields []NodeMetaField

		Inv Inv
	}))(obj)).Inv).Deserialize(r))
}

func (obj *MinimapMode) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Type).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.MinimapType", err))
	}
	if len(([]byte((*(*(struct {
		Type  MinimapType
		Label string
		Size  uint16
		Texture
		Scale uint16
	}))(obj)).Label))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Label))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Label))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Size
		write16(w, uint16(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Texture).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
	}
	{
		x := (*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Scale
		write16(w, uint16(x))
	}
}

func (obj *MinimapMode) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Type).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.MinimapType", err))
	}
	var local249 []uint8
	var local250 uint16
	{
		p := &local250
		*p = read16(r)
	}
	(local249) = make([]uint8, local250)
	{
		_, err := io.ReadFull(r, (local249)[:])
		chk(err)
	}
	((*(*(struct {
		Type  MinimapType
		Label string
		Size  uint16
		Texture
		Scale uint16
	}))(obj)).Label) = string(local249)
	{
		p := &(*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Size
		*p = read16(r)
	}
	if err := pcall(func() {
		((*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Texture).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
	}
	{
		p := &(*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Scale
		*p = read16(r)
	}
}

func (obj *NodeDef) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse
		}))(obj)).Param0).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Content", err))
	}
	{
		ow := w
		w := new(bytes.Buffer)
		{
			local251 := uint8(13)
			{
				x := local251
				write8(w, uint8(x))
			}
		}
		if len(([]byte((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse
		}))(obj)).Name))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).Name))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).Name))[:])
			chk(err)
		}
		if len(((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse
		}))(obj)).Groups)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).Groups)))
			write16(w, uint16(x))
		}
		for local252 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse
		}))(obj)).Groups {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse
				}))(obj)).Groups)[local252]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Group", err))
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).P1Type).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Param1Type", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).P2Type).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Param2Type", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).DrawType).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.DrawType", err))
		}
		if len(([]byte((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse
		}))(obj)).Mesh))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).Mesh))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).Mesh))[:])
			chk(err)
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).Scale
			write32(w, math.Float32bits(x))
		}
		{
			local253 := uint8(6)
			{
				x := local253
				write8(w, uint8(x))
			}
		}
		for local254 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse
		}))(obj)).Tiles {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse
				}))(obj)).Tiles)[local254]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.TileDef", err))
			}
		}
		for local255 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse
		}))(obj)).OverlayTiles {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse
				}))(obj)).OverlayTiles)[local255]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.TileDef", err))
			}
		}
		{
			local256 := uint8(6)
			{
				x := local256
				write8(w, uint8(x))
			}
		}
		for local257 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse
		}))(obj)).SpecialTiles {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse
				}))(obj)).SpecialTiles)[local257]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.TileDef", err))
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).Color
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).Palette).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).Waving).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.WaveType", err))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).ConnectSides
			write8(w, uint8(x))
		}
		if len(((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse
		}))(obj)).ConnectTo)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).ConnectTo)))
			write16(w, uint16(x))
		}
		for local258 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse
		}))(obj)).ConnectTo {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse
				}))(obj)).ConnectTo)[local258]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Content", err))
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).InsideTint
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).Level
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).Translucent
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).Transparent
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).LightSrc
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).GndContent
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).Collides
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).Pointable
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).Diggable
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).Climbable
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).Replaceable
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).OnRightClick
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).DmgPerSec
			write32(w, uint32(x))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).LiquidType).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.LiquidType", err))
		}
		if len(([]byte((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse
		}))(obj)).FlowingAlt))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).FlowingAlt))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).FlowingAlt))[:])
			chk(err)
		}
		if len(([]byte((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse
		}))(obj)).SrcAlt))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).SrcAlt))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).SrcAlt))[:])
			chk(err)
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).Viscosity
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).LiqRenewable
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).FlowRange
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).DrownDmg
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).Floodable
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).DrawBox).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.NodeBox", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).ColBox).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.NodeBox", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).SelBox).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.NodeBox", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).FootstepSnd).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.SoundDef", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).DiggingSnd).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.SoundDef", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).DugSnd).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.SoundDef", err))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).LegacyFaceDir
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).LegacyMounted
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		if len(([]byte((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse
		}))(obj)).DigPredict))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).DigPredict))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).DigPredict))[:])
			chk(err)
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).MaxLvl
			write8(w, uint8(x))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).AlphaUse).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AlphaUse", err))
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint16 {
				chk(ErrTooLong)
			}
			{
				x := uint16(len((buf.Bytes())))
				write16(w, uint16(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *NodeDef) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse
		}))(obj)).Param0).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Content", err))
	}
	{
		var n uint16
		{
			p := &n
			*p = read16(r)
		}
		r := &io.LimitedReader{r, int64(n)}
		{
			var local259 uint8
			{
				p := &local259
				*p = read8(r)
			}
			if local259 != (13) {
				chk(fmt.Errorf("const %v: %v", 13, local259))
			}
		}
		var local260 []uint8
		var local261 uint16
		{
			p := &local261
			*p = read16(r)
		}
		(local260) = make([]uint8, local261)
		{
			_, err := io.ReadFull(r, (local260)[:])
			chk(err)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse
		}))(obj)).Name) = string(local260)
		var local262 uint16
		{
			p := &local262
			*p = read16(r)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse
		}))(obj)).Groups) = make([]Group, local262)
		for local263 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse
		}))(obj)).Groups {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse
				}))(obj)).Groups)[local263]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Group", err))
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).P1Type).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Param1Type", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).P2Type).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Param2Type", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).DrawType).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.DrawType", err))
		}
		var local264 []uint8
		var local265 uint16
		{
			p := &local265
			*p = read16(r)
		}
		(local264) = make([]uint8, local265)
		{
			_, err := io.ReadFull(r, (local264)[:])
			chk(err)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse
		}))(obj)).Mesh) = string(local264)
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).Scale
			*p = math.Float32frombits(read32(r))
		}
		{
			var local266 uint8
			{
				p := &local266
				*p = read8(r)
			}
			if local266 != (6) {
				chk(fmt.Errorf("const %v: %v", 6, local266))
			}
		}
		for local267 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse
		}))(obj)).Tiles {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse
				}))(obj)).Tiles)[local267]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.TileDef", err))
			}
		}
		for local268 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse
		}))(obj)).OverlayTiles {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse
				}))(obj)).OverlayTiles)[local268]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.TileDef", err))
			}
		}
		{
			var local269 uint8
			{
				p := &local269
				*p = read8(r)
			}
			if local269 != (6) {
				chk(fmt.Errorf("const %v: %v", 6, local269))
			}
		}
		for local270 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse
		}))(obj)).SpecialTiles {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse
				}))(obj)).SpecialTiles)[local270]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.TileDef", err))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).Color
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).Palette).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).Waving).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.WaveType", err))
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).ConnectSides
			*p = read8(r)
		}
		var local271 uint16
		{
			p := &local271
			*p = read16(r)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse
		}))(obj)).ConnectTo) = make([]Content, local271)
		for local272 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse
		}))(obj)).ConnectTo {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse
				}))(obj)).ConnectTo)[local272]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Content", err))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).InsideTint
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).Level
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).Translucent
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).Transparent
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).LightSrc
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).GndContent
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).Collides
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).Pointable
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).Diggable
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).Climbable
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).Replaceable
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).OnRightClick
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).DmgPerSec
			*p = int32(read32(r))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).LiquidType).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.LiquidType", err))
		}
		var local273 []uint8
		var local274 uint16
		{
			p := &local274
			*p = read16(r)
		}
		(local273) = make([]uint8, local274)
		{
			_, err := io.ReadFull(r, (local273)[:])
			chk(err)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse
		}))(obj)).FlowingAlt) = string(local273)
		var local275 []uint8
		var local276 uint16
		{
			p := &local276
			*p = read16(r)
		}
		(local275) = make([]uint8, local276)
		{
			_, err := io.ReadFull(r, (local275)[:])
			chk(err)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse
		}))(obj)).SrcAlt) = string(local275)
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).Viscosity
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).LiqRenewable
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).FlowRange
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).DrownDmg
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).Floodable
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).DrawBox).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.NodeBox", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).ColBox).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.NodeBox", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).SelBox).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.NodeBox", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).FootstepSnd).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.SoundDef", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).DiggingSnd).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.SoundDef", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).DugSnd).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.SoundDef", err))
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).LegacyFaceDir
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).LegacyMounted
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		var local277 []uint8
		var local278 uint16
		{
			p := &local278
			*p = read16(r)
		}
		(local277) = make([]uint8, local278)
		{
			_, err := io.ReadFull(r, (local277)[:])
			chk(err)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse
		}))(obj)).DigPredict) = string(local277)
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).MaxLvl
			*p = read8(r)
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse
			}))(obj)).AlphaUse).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AlphaUse", err))
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *PointedNode) serialize(w io.Writer) {
	for local279 := range (*(*(struct {
		Under, Above [3]int16
	}))(obj)).Under {
		{
			x := ((*(*(struct {
				Under, Above [3]int16
			}))(obj)).Under)[local279]
			write16(w, uint16(x))
		}
	}
	for local280 := range (*(*(struct {
		Under, Above [3]int16
	}))(obj)).Above {
		{
			x := ((*(*(struct {
				Under, Above [3]int16
			}))(obj)).Above)[local280]
			write16(w, uint16(x))
		}
	}
}

func (obj *PointedNode) deserialize(r io.Reader) {
	for local281 := range (*(*(struct {
		Under, Above [3]int16
	}))(obj)).Under {
		{
			p := &((*(*(struct {
				Under, Above [3]int16
			}))(obj)).Under)[local281]
			*p = int16(read16(r))
		}
	}
	for local282 := range (*(*(struct {
		Under, Above [3]int16
	}))(obj)).Above {
		{
			p := &((*(*(struct {
				Under, Above [3]int16
			}))(obj)).Above)[local282]
			*p = int16(read16(r))
		}
	}
}

func (obj *PointedAO) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AOID", err))
	}
}

func (obj *PointedAO) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AOID", err))
	}
}

func (obj *CompressionModes) serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *CompressionModes) deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *PlayerPos) serialize(w io.Writer) {
	for local283 := range (*(*(struct {
		Pos100, Vel100   [3]int32
		Pitch100, Yaw100 int32
		Keys             Keys
		FOV80            uint8
		WantedRange      uint8 // in MapBlks.
	}))(obj)).Pos100 {
		{
			x := ((*(*(struct {
				Pos100, Vel100   [3]int32
				Pitch100, Yaw100 int32
				Keys             Keys
				FOV80            uint8
				WantedRange      uint8 // in MapBlks.
			}))(obj)).Pos100)[local283]
			write32(w, uint32(x))
		}
	}
	for local284 := range (*(*(struct {
		Pos100, Vel100   [3]int32
		Pitch100, Yaw100 int32
		Keys             Keys
		FOV80            uint8
		WantedRange      uint8 // in MapBlks.
	}))(obj)).Vel100 {
		{
			x := ((*(*(struct {
				Pos100, Vel100   [3]int32
				Pitch100, Yaw100 int32
				Keys             Keys
				FOV80            uint8
				WantedRange      uint8 // in MapBlks.
			}))(obj)).Vel100)[local284]
			write32(w, uint32(x))
		}
	}
	{
		x := (*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).Pitch100
		write32(w, uint32(x))
	}
	{
		x := (*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).Yaw100
		write32(w, uint32(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).Keys).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Keys", err))
	}
	{
		x := (*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).FOV80
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).WantedRange
		write8(w, uint8(x))
	}
}

func (obj *PlayerPos) deserialize(r io.Reader) {
	for local285 := range (*(*(struct {
		Pos100, Vel100   [3]int32
		Pitch100, Yaw100 int32
		Keys             Keys
		FOV80            uint8
		WantedRange      uint8 // in MapBlks.
	}))(obj)).Pos100 {
		{
			p := &((*(*(struct {
				Pos100, Vel100   [3]int32
				Pitch100, Yaw100 int32
				Keys             Keys
				FOV80            uint8
				WantedRange      uint8 // in MapBlks.
			}))(obj)).Pos100)[local285]
			*p = int32(read32(r))
		}
	}
	for local286 := range (*(*(struct {
		Pos100, Vel100   [3]int32
		Pitch100, Yaw100 int32
		Keys             Keys
		FOV80            uint8
		WantedRange      uint8 // in MapBlks.
	}))(obj)).Vel100 {
		{
			p := &((*(*(struct {
				Pos100, Vel100   [3]int32
				Pitch100, Yaw100 int32
				Keys             Keys
				FOV80            uint8
				WantedRange      uint8 // in MapBlks.
			}))(obj)).Vel100)[local286]
			*p = int32(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).Pitch100
		*p = int32(read32(r))
	}
	{
		p := &(*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).Yaw100
		*p = int32(read32(r))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).Keys).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Keys", err))
	}
	{
		p := &(*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).FOV80
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).WantedRange
		*p = read8(r)
	}
}

func (obj *Interaction) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *Interaction) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *SoundID) serialize(w io.Writer) {
	{
		x := *(*(int32))(obj)
		write32(w, uint32(x))
	}
}

func (obj *SoundID) deserialize(r io.Reader) {
	{
		p := &*(*(int32))(obj)
		*p = int32(read32(r))
	}
}

func (obj *Field) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Name string

		//mt:len32
		Value string
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Name string

			//mt:len32
			Value string
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name string

			//mt:len32
			Value string
		}))(obj)).Name))[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		Name string

		//mt:len32
		Value string
	}))(obj)).Value))) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(([]byte((*(*(struct {
			Name string

			//mt:len32
			Value string
		}))(obj)).Value))))
		write32(w, uint32(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name string

			//mt:len32
			Value string
		}))(obj)).Value))[:])
		chk(err)
	}
}

func (obj *Field) deserialize(r io.Reader) {
	var local287 []uint8
	var local288 uint16
	{
		p := &local288
		*p = read16(r)
	}
	(local287) = make([]uint8, local288)
	{
		_, err := io.ReadFull(r, (local287)[:])
		chk(err)
	}
	((*(*(struct {
		Name string

		//mt:len32
		Value string
	}))(obj)).Name) = string(local287)
	var local289 []uint8
	var local290 uint32
	{
		p := &local290
		*p = read32(r)
	}
	(local289) = make([]uint8, local290)
	{
		_, err := io.ReadFull(r, (local289)[:])
		chk(err)
	}
	((*(*(struct {
		Name string

		//mt:len32
		Value string
	}))(obj)).Value) = string(local289)
}

func (obj *AuthMethods) serialize(w io.Writer) {
	{
		x := *(*(uint32))(obj)
		write32(w, uint32(x))
	}
}

func (obj *AuthMethods) deserialize(r io.Reader) {
	{
		p := &*(*(uint32))(obj)
		*p = read32(r)
	}
}

func (obj *Pos) serialize(w io.Writer) {
	if err := pcall(func() {
		(*(*(Vec))(obj)).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Vec", err))
	}
}

func (obj *Pos) deserialize(r io.Reader) {
	if err := pcall(func() {
		(*(*(Vec))(obj)).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Vec", err))
	}
}

func (obj *DiscoReason) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *DiscoReason) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *MapBlk) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			//mt:zlib
			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).Flags).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.MapBlkFlags", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			//mt:zlib
			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).LitFrom).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.LitFromBlks", err))
	}
	{
		local291 := uint8(2) // Size of param0 in bytes.
		{
			x := local291
			write8(w, uint8(x))
		}
	}
	{
		local292 := uint8(1 + 1) // Size of param1 and param2 combined, in bytes.
		{
			x := local292
			write8(w, uint8(x))
		}
	}
	{
		w := zlib.NewWriter(w)
		for local293 := range (*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			//mt:zlib
			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).Param0 {
			if err := pcall(func() {
				(((*(*(struct {
					Flags   MapBlkFlags
					LitFrom LitFromBlks

					//mt:zlib
					Param0 [4096]Content
					Param1 [4096]uint8
					Param2 [4096]uint8

					NodeMetas map[uint16]*NodeMeta
				}))(obj)).Param0)[local293]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Content", err))
			}
		}
		{
			_, err := w.Write(((*(*(struct {
				Flags   MapBlkFlags
				LitFrom LitFromBlks

				//mt:zlib
				Param0 [4096]Content
				Param1 [4096]uint8
				Param2 [4096]uint8

				NodeMetas map[uint16]*NodeMeta
			}))(obj)).Param1)[:])
			chk(err)
		}
		{
			_, err := w.Write(((*(*(struct {
				Flags   MapBlkFlags
				LitFrom LitFromBlks

				//mt:zlib
				Param0 [4096]Content
				Param1 [4096]uint8
				Param2 [4096]uint8

				NodeMetas map[uint16]*NodeMeta
			}))(obj)).Param2)[:])
			chk(err)
		}
		chk(w.Close())
	}
	{
		x := (*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			//mt:zlib
			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).NodeMetas
		{
			w := zlib.NewWriter(w)
			if x == nil {
				write8(w, 0)
			} else {
				write8(w, 2)
				if len(x) > math.MaxUint16 {
					chk(ErrTooLong)
				}
				write16(w, uint16(len(x)))
				keys := make([]uint16, 0, len(x))
				for key := range x {
					keys = append(keys, key)
				}
				sort.Slice(keys, func(i, j int) bool {
					i2pos := func(i int) [3]int16 {
						return Blkpos2Pos([3]int16{}, keys[i])
					}
					p, q := i2pos(i), i2pos(j)
					for i := range p {
						switch {
						case p[i] < q[i]:
							return true
						case p[i] > q[i]:
							return false
						}
					}
					return false
				})
				for _, key := range keys {
					write16(w, key)
					chk(serialize(w, x[key]))
				}
			}
			chk(w.Close())
		}
	}
	{
		local294 := uint8(2) // version
		{
			x := local294
			write8(w, uint8(x))
		}
	}
}

func (obj *MapBlk) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			//mt:zlib
			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).Flags).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.MapBlkFlags", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			//mt:zlib
			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).LitFrom).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.LitFromBlks", err))
	}
	{
		var local295 uint8
		{
			p := &local295
			*p = read8(r)
		}
		if local295 != (2) {
			chk(fmt.Errorf("const %v: %v", 2, local295))
		}
	}
	{
		var local296 uint8
		{
			p := &local296
			*p = read8(r)
		}
		if local296 != (2) {
			chk(fmt.Errorf("const %v: %v", 2, local296))
		}
	}
	{
		r, err := zlib.NewReader(byteReader{r})
		chk(err)
		for local297 := range (*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			//mt:zlib
			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).Param0 {
			if err := pcall(func() {
				(((*(*(struct {
					Flags   MapBlkFlags
					LitFrom LitFromBlks

					//mt:zlib
					Param0 [4096]Content
					Param1 [4096]uint8
					Param2 [4096]uint8

					NodeMetas map[uint16]*NodeMeta
				}))(obj)).Param0)[local297]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Content", err))
			}
		}
		{
			_, err := io.ReadFull(r, ((*(*(struct {
				Flags   MapBlkFlags
				LitFrom LitFromBlks

				//mt:zlib
				Param0 [4096]Content
				Param1 [4096]uint8
				Param2 [4096]uint8

				NodeMetas map[uint16]*NodeMeta
			}))(obj)).Param1)[:])
			chk(err)
		}
		{
			_, err := io.ReadFull(r, ((*(*(struct {
				Flags   MapBlkFlags
				LitFrom LitFromBlks

				//mt:zlib
				Param0 [4096]Content
				Param1 [4096]uint8
				Param2 [4096]uint8

				NodeMetas map[uint16]*NodeMeta
			}))(obj)).Param2)[:])
			chk(err)
		}
		chk(r.Close())
	}
	{
		p := &(*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			//mt:zlib
			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).NodeMetas
		{
			r, err := zlib.NewReader(byteReader{r})
			chk(err)
			switch ver := read8(r); ver {
			case 0:
				*p = nil
			case 2:
				n := read16(r)
				*p = make(map[uint16]*NodeMeta, n)
				for ; n > 0; n-- {
					pos := read16(r)
					nm := new(NodeMeta)
					chk(deserialize(r, nm))
					(*p)[pos] = nm
				}
			default:
				chk(fmt.Errorf("unsupported nodemetas version: %d", ver))
			}
			chk(r.Close())
		}
	}
	{
		var local298 uint8
		{
			p := &local298
			*p = read8(r)
		}
		if local298 != (2) {
			chk(fmt.Errorf("const %v: %v", 2, local298))
		}
	}
}

func (obj *Node) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Param0         Content
			Param1, Param2 uint8
		}))(obj)).Param0).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Content", err))
	}
	{
		x := (*(*(struct {
			Param0         Content
			Param1, Param2 uint8
		}))(obj)).Param1
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			Param0         Content
			Param1, Param2 uint8
		}))(obj)).Param2
		write8(w, uint8(x))
	}
}

func (obj *Node) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Param0         Content
			Param1, Param2 uint8
		}))(obj)).Param0).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Content", err))
	}
	{
		p := &(*(*(struct {
			Param0         Content
			Param1, Param2 uint8
		}))(obj)).Param1
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			Param0         Content
			Param1, Param2 uint8
		}))(obj)).Param2
		*p = read8(r)
	}
}

func (obj *CSMRestrictionFlags) serialize(w io.Writer) {
	{
		x := *(*(uint64))(obj)
		write64(w, uint64(x))
	}
}

func (obj *CSMRestrictionFlags) deserialize(r io.Reader) {
	{
		p := &*(*(uint64))(obj)
		*p = read64(r)
	}
}

func (obj *Vec) serialize(w io.Writer) {
	for local299 := range *(*([3]float32))(obj) {
		{
			x := (*(*([3]float32))(obj))[local299]
			write32(w, math.Float32bits(x))
		}
	}
}

func (obj *Vec) deserialize(r io.Reader) {
	for local300 := range *(*([3]float32))(obj) {
		{
			p := &(*(*([3]float32))(obj))[local300]
			*p = math.Float32frombits(read32(r))
		}
	}
}

func (obj *ChatMsgType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *ChatMsgType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *AOID) serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *AOID) deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *aoType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *aoType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *AOInitData) serialize(w io.Writer) {
	{
		local301 := uint8(1)
		{
			x := local301
			write8(w, uint8(x))
		}
	}
	if len(([]byte((*(*(struct {

		// For players.
		Name     string
		IsPlayer bool

		ID AOID

		Pos
		Rot [3]float32

		HP uint16

		// See (de)serialize.fmt.
		Msgs []AOMsg
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).Name))[:])
		chk(err)
	}
	{
		x := (*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).IsPlayer
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AOID", err))
	}
	if err := pcall(func() {
		((*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Pos", err))
	}
	for local302 := range (*(*(struct {

		// For players.
		Name     string
		IsPlayer bool

		ID AOID

		Pos
		Rot [3]float32

		HP uint16

		// See (de)serialize.fmt.
		Msgs []AOMsg
	}))(obj)).Rot {
		{
			x := ((*(*(struct {

				// For players.
				Name     string
				IsPlayer bool

				ID AOID

				Pos
				Rot [3]float32

				HP uint16

				// See (de)serialize.fmt.
				Msgs []AOMsg
			}))(obj)).Rot)[local302]
			write32(w, math.Float32bits(x))
		}
	}
	{
		x := (*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).HP
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).Msgs
		{ // For AOInitData.Msgs.
			if len(x) > math.MaxUint8 {
				chk(ErrTooLong)
			}
			write8(w, uint8(len(x)))
			for _, msg := range x {
				var b bytes.Buffer
				chk(writeAOMsg(&b, msg))
				if b.Len() > math.MaxUint32 {
					chk(ErrTooLong)
				}
				write32(w, uint32(b.Len()))
				_, err := b.WriteTo(w)
				chk(err)
			}
		}
	}
}

func (obj *AOInitData) deserialize(r io.Reader) {
	{
		var local303 uint8
		{
			p := &local303
			*p = read8(r)
		}
		if local303 != (1) {
			chk(fmt.Errorf("const %v: %v", 1, local303))
		}
	}
	var local304 []uint8
	var local305 uint16
	{
		p := &local305
		*p = read16(r)
	}
	(local304) = make([]uint8, local305)
	{
		_, err := io.ReadFull(r, (local304)[:])
		chk(err)
	}
	((*(*(struct {

		// For players.
		Name     string
		IsPlayer bool

		ID AOID

		Pos
		Rot [3]float32

		HP uint16

		// See (de)serialize.fmt.
		Msgs []AOMsg
	}))(obj)).Name) = string(local304)
	{
		p := &(*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).IsPlayer
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AOID", err))
	}
	if err := pcall(func() {
		((*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Pos", err))
	}
	for local306 := range (*(*(struct {

		// For players.
		Name     string
		IsPlayer bool

		ID AOID

		Pos
		Rot [3]float32

		HP uint16

		// See (de)serialize.fmt.
		Msgs []AOMsg
	}))(obj)).Rot {
		{
			p := &((*(*(struct {

				// For players.
				Name     string
				IsPlayer bool

				ID AOID

				Pos
				Rot [3]float32

				HP uint16

				// See (de)serialize.fmt.
				Msgs []AOMsg
			}))(obj)).Rot)[local306]
			*p = math.Float32frombits(read32(r))
		}
	}
	{
		p := &(*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).HP
		*p = read16(r)
	}
	{
		p := &(*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).Msgs
		{ // For AOInitData.Msgs.
			*p = make([]AOMsg, read8(r))
			for i := range *p {
				r := &io.LimitedReader{r, int64(read32(r))}
				msg, err := readAOMsg(r)
				chk(err)
				(*p)[i] = msg
				if r.N > 0 {
					chk(fmt.Errorf("%d bytes of trailing data", r.N))
				}
			}
		}
	}
}

func (obj *IDAOMsg) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
			//mt:lenhdr 16
			Msg AOMsg
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AOID", err))
	}
	{
		ow := w
		w := new(bytes.Buffer)
		{
			x := (*(*(struct {
				ID AOID
				//mt:lenhdr 16
				Msg AOMsg
			}))(obj)).Msg
			writeAOMsg(w, x)
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint16 {
				chk(ErrTooLong)
			}
			{
				x := uint16(len((buf.Bytes())))
				write16(w, uint16(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *IDAOMsg) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
			//mt:lenhdr 16
			Msg AOMsg
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AOID", err))
	}
	{
		var n uint16
		{
			p := &n
			*p = read16(r)
		}
		r := &io.LimitedReader{r, int64(n)}
		{
			p := &(*(*(struct {
				ID AOID
				//mt:lenhdr 16
				Msg AOMsg
			}))(obj)).Msg
			{
				var err error
				*p, err = readAOMsg(r)
				chk(err)
			}
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *ItemDef) serialize(w io.Writer) {
	{
		ow := w
		w := new(bytes.Buffer)
		{
			local307 := uint8(6)
			{
				x := local307
				write8(w, uint8(x))
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).Type).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.ItemType", err))
		}
		if len(([]byte((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 byte
		}))(obj)).Name))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).Name))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).Name))[:])
			chk(err)
		}
		if len(([]byte((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 byte
		}))(obj)).Desc))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).Desc))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).Desc))[:])
			chk(err)
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).InvImg).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).WieldImg).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
		}
		for local308 := range (*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 byte
		}))(obj)).WieldScale {
			{
				x := ((*(*(struct {
					Type ItemType

					Name, Desc string

					InvImg, WieldImg Texture
					WieldScale       [3]float32

					StackMax uint16

					Usable          bool
					CanPointLiquids bool

					ToolCaps ToolCaps

					Groups []Group

					PlacePredict string

					PlaceSnd, PlaceFailSnd SoundDef

					PointRange float32

					// Set index in Palette with "palette_index" item meta field,
					// this overrides Color.
					Palette Texture
					Color   color.NRGBA

					// Texture overlays.
					InvOverlay, WieldOverlay Texture

					ShortDesc string

					PlaceParam2 byte
				}))(obj)).WieldScale)[local308]
				write32(w, math.Float32bits(x))
			}
		}
		{
			x := (*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).StackMax
			write16(w, uint16(x))
		}
		{
			x := (*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).Usable
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).CanPointLiquids
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).ToolCaps).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.ToolCaps", err))
		}
		if len(((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 byte
		}))(obj)).Groups)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).Groups)))
			write16(w, uint16(x))
		}
		for local309 := range (*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 byte
		}))(obj)).Groups {
			if err := pcall(func() {
				(((*(*(struct {
					Type ItemType

					Name, Desc string

					InvImg, WieldImg Texture
					WieldScale       [3]float32

					StackMax uint16

					Usable          bool
					CanPointLiquids bool

					ToolCaps ToolCaps

					Groups []Group

					PlacePredict string

					PlaceSnd, PlaceFailSnd SoundDef

					PointRange float32

					// Set index in Palette with "palette_index" item meta field,
					// this overrides Color.
					Palette Texture
					Color   color.NRGBA

					// Texture overlays.
					InvOverlay, WieldOverlay Texture

					ShortDesc string

					PlaceParam2 byte
				}))(obj)).Groups)[local309]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Group", err))
			}
		}
		if len(([]byte((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 byte
		}))(obj)).PlacePredict))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).PlacePredict))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).PlacePredict))[:])
			chk(err)
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).PlaceSnd).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.SoundDef", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).PlaceFailSnd).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.SoundDef", err))
		}
		{
			x := (*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).PointRange
			write32(w, math.Float32bits(x))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).Palette).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
		}
		{
			x := (*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).Color
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).InvOverlay).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).WieldOverlay).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
		}
		if len(([]byte((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 byte
		}))(obj)).ShortDesc))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).ShortDesc))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).ShortDesc))[:])
			chk(err)
		}
		{
			x := (*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).PlaceParam2
			write8(w, uint8(x))
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint16 {
				chk(ErrTooLong)
			}
			{
				x := uint16(len((buf.Bytes())))
				write16(w, uint16(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *ItemDef) deserialize(r io.Reader) {
	{
		var n uint16
		{
			p := &n
			*p = read16(r)
		}
		r := &io.LimitedReader{r, int64(n)}
		{
			var local310 uint8
			{
				p := &local310
				*p = read8(r)
			}
			if local310 != (6) {
				chk(fmt.Errorf("const %v: %v", 6, local310))
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).Type).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.ItemType", err))
		}
		var local311 []uint8
		var local312 uint16
		{
			p := &local312
			*p = read16(r)
		}
		(local311) = make([]uint8, local312)
		{
			_, err := io.ReadFull(r, (local311)[:])
			chk(err)
		}
		((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 byte
		}))(obj)).Name) = string(local311)
		var local313 []uint8
		var local314 uint16
		{
			p := &local314
			*p = read16(r)
		}
		(local313) = make([]uint8, local314)
		{
			_, err := io.ReadFull(r, (local313)[:])
			chk(err)
		}
		((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 byte
		}))(obj)).Desc) = string(local313)
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).InvImg).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).WieldImg).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
		}
		for local315 := range (*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 byte
		}))(obj)).WieldScale {
			{
				p := &((*(*(struct {
					Type ItemType

					Name, Desc string

					InvImg, WieldImg Texture
					WieldScale       [3]float32

					StackMax uint16

					Usable          bool
					CanPointLiquids bool

					ToolCaps ToolCaps

					Groups []Group

					PlacePredict string

					PlaceSnd, PlaceFailSnd SoundDef

					PointRange float32

					// Set index in Palette with "palette_index" item meta field,
					// this overrides Color.
					Palette Texture
					Color   color.NRGBA

					// Texture overlays.
					InvOverlay, WieldOverlay Texture

					ShortDesc string

					PlaceParam2 byte
				}))(obj)).WieldScale)[local315]
				*p = math.Float32frombits(read32(r))
			}
		}
		{
			p := &(*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).StackMax
			*p = read16(r)
		}
		{
			p := &(*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).Usable
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).CanPointLiquids
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).ToolCaps).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.ToolCaps", err))
		}
		var local316 uint16
		{
			p := &local316
			*p = read16(r)
		}
		((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 byte
		}))(obj)).Groups) = make([]Group, local316)
		for local317 := range (*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 byte
		}))(obj)).Groups {
			if err := pcall(func() {
				(((*(*(struct {
					Type ItemType

					Name, Desc string

					InvImg, WieldImg Texture
					WieldScale       [3]float32

					StackMax uint16

					Usable          bool
					CanPointLiquids bool

					ToolCaps ToolCaps

					Groups []Group

					PlacePredict string

					PlaceSnd, PlaceFailSnd SoundDef

					PointRange float32

					// Set index in Palette with "palette_index" item meta field,
					// this overrides Color.
					Palette Texture
					Color   color.NRGBA

					// Texture overlays.
					InvOverlay, WieldOverlay Texture

					ShortDesc string

					PlaceParam2 byte
				}))(obj)).Groups)[local317]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Group", err))
			}
		}
		var local318 []uint8
		var local319 uint16
		{
			p := &local319
			*p = read16(r)
		}
		(local318) = make([]uint8, local319)
		{
			_, err := io.ReadFull(r, (local318)[:])
			chk(err)
		}
		((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 byte
		}))(obj)).PlacePredict) = string(local318)
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).PlaceSnd).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.SoundDef", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).PlaceFailSnd).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.SoundDef", err))
		}
		{
			p := &(*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).PointRange
			*p = math.Float32frombits(read32(r))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).Palette).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
		}
		{
			p := &(*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).Color
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).InvOverlay).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).WieldOverlay).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
		}
		var local320 []uint8
		var local321 uint16
		{
			p := &local321
			*p = read16(r)
		}
		(local320) = make([]uint8, local321)
		{
			_, err := io.ReadFull(r, (local320)[:])
			chk(err)
		}
		((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 byte
		}))(obj)).ShortDesc) = string(local320)
		{
			p := &(*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 byte
			}))(obj)).PlaceParam2
			*p = read8(r)
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *SoundSrcType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *SoundSrcType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *TileAnim) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Type AnimType

			//mt:if %s.Type == SpriteSheetAnim
			AspectRatio [2]uint8

			//mt:if %s.Type == VerticalFrameAnim
			NFrames [2]uint16

			//mt:if %s.Type != NoAnim
			Duration float32 // in seconds

		}))(obj)).Type).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AnimType", err))
	}
	if !((*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type < maxAnim) {
		chk(errors.New("assertion failed: %s.Type < maxAnim"))
	}
	if (*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type == SpriteSheetAnim {
		{
			_, err := w.Write(((*(*(struct {
				Type AnimType

				//mt:if %s.Type == SpriteSheetAnim
				AspectRatio [2]uint8

				//mt:if %s.Type == VerticalFrameAnim
				NFrames [2]uint16

				//mt:if %s.Type != NoAnim
				Duration float32 // in seconds

			}))(obj)).AspectRatio)[:])
			chk(err)
		}
	}
	if (*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type == VerticalFrameAnim {
		for local322 := range (*(*(struct {
			Type AnimType

			//mt:if %s.Type == SpriteSheetAnim
			AspectRatio [2]uint8

			//mt:if %s.Type == VerticalFrameAnim
			NFrames [2]uint16

			//mt:if %s.Type != NoAnim
			Duration float32 // in seconds

		}))(obj)).NFrames {
			{
				x := ((*(*(struct {
					Type AnimType

					//mt:if %s.Type == SpriteSheetAnim
					AspectRatio [2]uint8

					//mt:if %s.Type == VerticalFrameAnim
					NFrames [2]uint16

					//mt:if %s.Type != NoAnim
					Duration float32 // in seconds

				}))(obj)).NFrames)[local322]
				write16(w, uint16(x))
			}
		}
	}
	if (*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type != NoAnim {
		{
			x := (*(*(struct {
				Type AnimType

				//mt:if %s.Type == SpriteSheetAnim
				AspectRatio [2]uint8

				//mt:if %s.Type == VerticalFrameAnim
				NFrames [2]uint16

				//mt:if %s.Type != NoAnim
				Duration float32 // in seconds

			}))(obj)).Duration
			write32(w, math.Float32bits(x))
		}
	}
}

func (obj *TileAnim) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Type AnimType

			//mt:if %s.Type == SpriteSheetAnim
			AspectRatio [2]uint8

			//mt:if %s.Type == VerticalFrameAnim
			NFrames [2]uint16

			//mt:if %s.Type != NoAnim
			Duration float32 // in seconds

		}))(obj)).Type).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AnimType", err))
	}
	if !((*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type < maxAnim) {
		chk(errors.New("assertion failed: %s.Type < maxAnim"))
	}
	if (*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type == SpriteSheetAnim {
		{
			_, err := io.ReadFull(r, ((*(*(struct {
				Type AnimType

				//mt:if %s.Type == SpriteSheetAnim
				AspectRatio [2]uint8

				//mt:if %s.Type == VerticalFrameAnim
				NFrames [2]uint16

				//mt:if %s.Type != NoAnim
				Duration float32 // in seconds

			}))(obj)).AspectRatio)[:])
			chk(err)
		}
	}
	if (*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type == VerticalFrameAnim {
		for local323 := range (*(*(struct {
			Type AnimType

			//mt:if %s.Type == SpriteSheetAnim
			AspectRatio [2]uint8

			//mt:if %s.Type == VerticalFrameAnim
			NFrames [2]uint16

			//mt:if %s.Type != NoAnim
			Duration float32 // in seconds

		}))(obj)).NFrames {
			{
				p := &((*(*(struct {
					Type AnimType

					//mt:if %s.Type == SpriteSheetAnim
					AspectRatio [2]uint8

					//mt:if %s.Type == VerticalFrameAnim
					NFrames [2]uint16

					//mt:if %s.Type != NoAnim
					Duration float32 // in seconds

				}))(obj)).NFrames)[local323]
				*p = read16(r)
			}
		}
	}
	if (*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type != NoAnim {
		{
			p := &(*(*(struct {
				Type AnimType

				//mt:if %s.Type == SpriteSheetAnim
				AspectRatio [2]uint8

				//mt:if %s.Type == VerticalFrameAnim
				NFrames [2]uint16

				//mt:if %s.Type != NoAnim
				Duration float32 // in seconds

			}))(obj)).Duration
			*p = math.Float32frombits(read32(r))
		}
	}
}

func (obj *Content) serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *Content) deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *ParticleSpawnerID) serialize(w io.Writer) {
	{
		x := *(*(uint32))(obj)
		write32(w, uint32(x))
	}
}

func (obj *ParticleSpawnerID) deserialize(r io.Reader) {
	{
		p := &*(*(uint32))(obj)
		*p = read32(r)
	}
}

func (obj *HUDID) serialize(w io.Writer) {
	{
		x := *(*(uint32))(obj)
		write32(w, uint32(x))
	}
}

func (obj *HUDID) deserialize(r io.Reader) {
	{
		p := &*(*(uint32))(obj)
		*p = read32(r)
	}
}

func (obj *HUDType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *HUDType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *HUDField) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *HUDField) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *HUDFlags) serialize(w io.Writer) {
	{
		x := *(*(uint32))(obj)
		write32(w, uint32(x))
	}
}

func (obj *HUDFlags) deserialize(r io.Reader) {
	{
		p := &*(*(uint32))(obj)
		*p = read32(r)
	}
}

func (obj *HotbarParam) serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *HotbarParam) deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *Texture) serialize(w io.Writer) {
	if len(([]byte(*(*(string))(obj)))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte(*(*(string))(obj)))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte(*(*(string))(obj)))[:])
		chk(err)
	}
}

func (obj *Texture) deserialize(r io.Reader) {
	var local324 []uint8
	var local325 uint16
	{
		p := &local325
		*p = read16(r)
	}
	(local324) = make([]uint8, local325)
	{
		_, err := io.ReadFull(r, (local324)[:])
		chk(err)
	}
	(*(*(string))(obj)) = string(local324)
}

func (obj *PlayerListUpdateType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *PlayerListUpdateType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *ModChanSig) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *ModChanSig) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *AOProps) serialize(w io.Writer) {
	{
		local326 := uint8(4)
		{
			x := local326
			write8(w, uint8(x))
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).MaxHP
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).CollideWithNodes
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Weight
		write32(w, math.Float32bits(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).ColBox).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Box", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).SelBox).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Box", err))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Pointable
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if len(([]byte((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Visual))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Visual))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Visual))[:])
		chk(err)
	}
	for local327 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).VisualSize {
		{
			x := ((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
			}))(obj)).VisualSize)[local327]
			write32(w, math.Float32bits(x))
		}
	}
	if len(((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Textures)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Textures)))
		write16(w, uint16(x))
	}
	for local328 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Textures {
		if err := pcall(func() {
			(((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
			}))(obj)).Textures)[local328]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
		}
	}
	for local329 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).SpriteSheetSize {
		{
			x := ((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
			}))(obj)).SpriteSheetSize)[local329]
			write16(w, uint16(x))
		}
	}
	for local330 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).SpritePos {
		{
			x := ((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
			}))(obj)).SpritePos)[local330]
			write16(w, uint16(x))
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Visible
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).MakeFootstepSnds
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).RotateSpeed
		write32(w, math.Float32bits(x))
	}
	if len(([]byte((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Mesh))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Mesh))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Mesh))[:])
		chk(err)
	}
	if len(((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Colors)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Colors)))
		write16(w, uint16(x))
	}
	for local331 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Colors {
		{
			x := ((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
			}))(obj)).Colors)[local331]
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).CollideWithAOs
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).StepHeight
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).FaceRotateDir
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).FaceRotateDirOff
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).BackfaceCull
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if len(([]byte((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Nametag))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Nametag))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Nametag))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).NametagColor
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).FaceRotateSpeed
		write32(w, math.Float32bits(x))
	}
	if len(([]byte((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Infotext))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Infotext))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Infotext))[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Itemstring))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Itemstring))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Itemstring))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Glow
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).MaxBreath
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).EyeHeight
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).ZoomFOV
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).UseTextureAlpha
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).DmgTextureMod).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Shaded
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).ShowOnMinimap
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).NametagBG
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
}

func (obj *AOProps) deserialize(r io.Reader) {
	{
		var local332 uint8
		{
			p := &local332
			*p = read8(r)
		}
		if local332 != (4) {
			chk(fmt.Errorf("const %v: %v", 4, local332))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).MaxHP
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).CollideWithNodes
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Weight
		*p = math.Float32frombits(read32(r))
	}
	if err := pcall(func() {
		((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).ColBox).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Box", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).SelBox).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Box", err))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Pointable
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	var local333 []uint8
	var local334 uint16
	{
		p := &local334
		*p = read16(r)
	}
	(local333) = make([]uint8, local334)
	{
		_, err := io.ReadFull(r, (local333)[:])
		chk(err)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Visual) = string(local333)
	for local335 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).VisualSize {
		{
			p := &((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
			}))(obj)).VisualSize)[local335]
			*p = math.Float32frombits(read32(r))
		}
	}
	var local336 uint16
	{
		p := &local336
		*p = read16(r)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Textures) = make([]Texture, local336)
	for local337 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Textures {
		if err := pcall(func() {
			(((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
			}))(obj)).Textures)[local337]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
		}
	}
	for local338 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).SpriteSheetSize {
		{
			p := &((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
			}))(obj)).SpriteSheetSize)[local338]
			*p = int16(read16(r))
		}
	}
	for local339 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).SpritePos {
		{
			p := &((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
			}))(obj)).SpritePos)[local339]
			*p = int16(read16(r))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Visible
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).MakeFootstepSnds
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).RotateSpeed
		*p = math.Float32frombits(read32(r))
	}
	var local340 []uint8
	var local341 uint16
	{
		p := &local341
		*p = read16(r)
	}
	(local340) = make([]uint8, local341)
	{
		_, err := io.ReadFull(r, (local340)[:])
		chk(err)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Mesh) = string(local340)
	var local342 uint16
	{
		p := &local342
		*p = read16(r)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Colors) = make([]color.NRGBA, local342)
	for local343 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Colors {
		{
			p := &((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
			}))(obj)).Colors)[local343]
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).CollideWithAOs
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).StepHeight
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).FaceRotateDir
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).FaceRotateDirOff
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).BackfaceCull
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	var local344 []uint8
	var local345 uint16
	{
		p := &local345
		*p = read16(r)
	}
	(local344) = make([]uint8, local345)
	{
		_, err := io.ReadFull(r, (local344)[:])
		chk(err)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Nametag) = string(local344)
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).NametagColor
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).FaceRotateSpeed
		*p = math.Float32frombits(read32(r))
	}
	var local346 []uint8
	var local347 uint16
	{
		p := &local347
		*p = read16(r)
	}
	(local346) = make([]uint8, local347)
	{
		_, err := io.ReadFull(r, (local346)[:])
		chk(err)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Infotext) = string(local346)
	var local348 []uint8
	var local349 uint16
	{
		p := &local349
		*p = read16(r)
	}
	(local348) = make([]uint8, local349)
	{
		_, err := io.ReadFull(r, (local348)[:])
		chk(err)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Itemstring) = string(local348)
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Glow
		*p = int8(read8(r))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).MaxBreath
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).EyeHeight
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).ZoomFOV
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).UseTextureAlpha
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).DmgTextureMod).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Shaded
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).ShowOnMinimap
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).NametagBG
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
}

func (obj *AOPos) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Pos", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Vel).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Vec", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Acc).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Vec", err))
	}
	for local350 := range (*(*(struct {
		Pos
		Vel, Acc Vec
		Rot      [3]float32

		Interpolate    bool
		End            bool
		UpdateInterval float32
	}))(obj)).Rot {
		{
			x := ((*(*(struct {
				Pos
				Vel, Acc Vec
				Rot      [3]float32

				Interpolate    bool
				End            bool
				UpdateInterval float32
			}))(obj)).Rot)[local350]
			write32(w, math.Float32bits(x))
		}
	}
	{
		x := (*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Interpolate
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).End
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).UpdateInterval
		write32(w, math.Float32bits(x))
	}
}

func (obj *AOPos) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Pos", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Vel).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Vec", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Acc).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Vec", err))
	}
	for local351 := range (*(*(struct {
		Pos
		Vel, Acc Vec
		Rot      [3]float32

		Interpolate    bool
		End            bool
		UpdateInterval float32
	}))(obj)).Rot {
		{
			p := &((*(*(struct {
				Pos
				Vel, Acc Vec
				Rot      [3]float32

				Interpolate    bool
				End            bool
				UpdateInterval float32
			}))(obj)).Rot)[local351]
			*p = math.Float32frombits(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Interpolate
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).End
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).UpdateInterval
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *AOSprite) serialize(w io.Writer) {
	for local352 := range (*(*(struct {
		Frame0          [2]int16
		Frames          uint16
		FrameDuration   float32
		ViewAngleFrames bool
	}))(obj)).Frame0 {
		{
			x := ((*(*(struct {
				Frame0          [2]int16
				Frames          uint16
				FrameDuration   float32
				ViewAngleFrames bool
			}))(obj)).Frame0)[local352]
			write16(w, uint16(x))
		}
	}
	{
		x := (*(*(struct {
			Frame0          [2]int16
			Frames          uint16
			FrameDuration   float32
			ViewAngleFrames bool
		}))(obj)).Frames
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			Frame0          [2]int16
			Frames          uint16
			FrameDuration   float32
			ViewAngleFrames bool
		}))(obj)).FrameDuration
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Frame0          [2]int16
			Frames          uint16
			FrameDuration   float32
			ViewAngleFrames bool
		}))(obj)).ViewAngleFrames
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *AOSprite) deserialize(r io.Reader) {
	for local353 := range (*(*(struct {
		Frame0          [2]int16
		Frames          uint16
		FrameDuration   float32
		ViewAngleFrames bool
	}))(obj)).Frame0 {
		{
			p := &((*(*(struct {
				Frame0          [2]int16
				Frames          uint16
				FrameDuration   float32
				ViewAngleFrames bool
			}))(obj)).Frame0)[local353]
			*p = int16(read16(r))
		}
	}
	{
		p := &(*(*(struct {
			Frame0          [2]int16
			Frames          uint16
			FrameDuration   float32
			ViewAngleFrames bool
		}))(obj)).Frames
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			Frame0          [2]int16
			Frames          uint16
			FrameDuration   float32
			ViewAngleFrames bool
		}))(obj)).FrameDuration
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Frame0          [2]int16
			Frames          uint16
			FrameDuration   float32
			ViewAngleFrames bool
		}))(obj)).ViewAngleFrames
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *Group) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Name   string
		Rating int16
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Name   string
			Rating int16
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name   string
			Rating int16
		}))(obj)).Name))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Name   string
			Rating int16
		}))(obj)).Rating
		write16(w, uint16(x))
	}
}

func (obj *Group) deserialize(r io.Reader) {
	var local354 []uint8
	var local355 uint16
	{
		p := &local355
		*p = read16(r)
	}
	(local354) = make([]uint8, local355)
	{
		_, err := io.ReadFull(r, (local354)[:])
		chk(err)
	}
	((*(*(struct {
		Name   string
		Rating int16
	}))(obj)).Name) = string(local354)
	{
		p := &(*(*(struct {
			Name   string
			Rating int16
		}))(obj)).Rating
		*p = int16(read16(r))
	}
}

func (obj *AOAnim) serialize(w io.Writer) {
	for local356 := range (*(*(struct {
		Frames [2]int32
		Speed  float32
		Blend  float32
		NoLoop bool
	}))(obj)).Frames {
		{
			x := ((*(*(struct {
				Frames [2]int32
				Speed  float32
				Blend  float32
				NoLoop bool
			}))(obj)).Frames)[local356]
			write32(w, uint32(x))
		}
	}
	{
		x := (*(*(struct {
			Frames [2]int32
			Speed  float32
			Blend  float32
			NoLoop bool
		}))(obj)).Speed
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Frames [2]int32
			Speed  float32
			Blend  float32
			NoLoop bool
		}))(obj)).Blend
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Frames [2]int32
			Speed  float32
			Blend  float32
			NoLoop bool
		}))(obj)).NoLoop
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *AOAnim) deserialize(r io.Reader) {
	for local357 := range (*(*(struct {
		Frames [2]int32
		Speed  float32
		Blend  float32
		NoLoop bool
	}))(obj)).Frames {
		{
			p := &((*(*(struct {
				Frames [2]int32
				Speed  float32
				Blend  float32
				NoLoop bool
			}))(obj)).Frames)[local357]
			*p = int32(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Frames [2]int32
			Speed  float32
			Blend  float32
			NoLoop bool
		}))(obj)).Speed
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Frames [2]int32
			Speed  float32
			Blend  float32
			NoLoop bool
		}))(obj)).Blend
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Frames [2]int32
			Speed  float32
			Blend  float32
			NoLoop bool
		}))(obj)).NoLoop
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *AOBonePos) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Pos Vec
			Rot [3]float32
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Vec", err))
	}
	for local358 := range (*(*(struct {
		Pos Vec
		Rot [3]float32
	}))(obj)).Rot {
		{
			x := ((*(*(struct {
				Pos Vec
				Rot [3]float32
			}))(obj)).Rot)[local358]
			write32(w, math.Float32bits(x))
		}
	}
}

func (obj *AOBonePos) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Pos Vec
			Rot [3]float32
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Vec", err))
	}
	for local359 := range (*(*(struct {
		Pos Vec
		Rot [3]float32
	}))(obj)).Rot {
		{
			p := &((*(*(struct {
				Pos Vec
				Rot [3]float32
			}))(obj)).Rot)[local359]
			*p = math.Float32frombits(read32(r))
		}
	}
}

func (obj *AOAttach) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).ParentID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AOID", err))
	}
	if len(([]byte((*(*(struct {
		ParentID     AOID
		Bone         string
		Pos          Vec
		Rot          [3]float32
		ForceVisible bool
	}))(obj)).Bone))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).Bone))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).Bone))[:])
		chk(err)
	}
	if err := pcall(func() {
		((*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Vec", err))
	}
	for local360 := range (*(*(struct {
		ParentID     AOID
		Bone         string
		Pos          Vec
		Rot          [3]float32
		ForceVisible bool
	}))(obj)).Rot {
		{
			x := ((*(*(struct {
				ParentID     AOID
				Bone         string
				Pos          Vec
				Rot          [3]float32
				ForceVisible bool
			}))(obj)).Rot)[local360]
			write32(w, math.Float32bits(x))
		}
	}
	{
		x := (*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).ForceVisible
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *AOAttach) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).ParentID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AOID", err))
	}
	var local361 []uint8
	var local362 uint16
	{
		p := &local362
		*p = read16(r)
	}
	(local361) = make([]uint8, local362)
	{
		_, err := io.ReadFull(r, (local361)[:])
		chk(err)
	}
	((*(*(struct {
		ParentID     AOID
		Bone         string
		Pos          Vec
		Rot          [3]float32
		ForceVisible bool
	}))(obj)).Bone) = string(local361)
	if err := pcall(func() {
		((*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Vec", err))
	}
	for local363 := range (*(*(struct {
		ParentID     AOID
		Bone         string
		Pos          Vec
		Rot          [3]float32
		ForceVisible bool
	}))(obj)).Rot {
		{
			p := &((*(*(struct {
				ParentID     AOID
				Bone         string
				Pos          Vec
				Rot          [3]float32
				ForceVisible bool
			}))(obj)).Rot)[local363]
			*p = math.Float32frombits(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).ForceVisible
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *AOPhysOverride) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).Walk
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).Jump
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).Gravity
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).NoSneak
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).NoSneakGlitch
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).OldSneak
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *AOPhysOverride) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).Walk
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).Jump
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).Gravity
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).NoSneak
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).NoSneakGlitch
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).OldSneak
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *NodeMetaField) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Field
			Private bool
		}))(obj)).Field).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Field", err))
	}
	{
		x := (*(*(struct {
			Field
			Private bool
		}))(obj)).Private
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *NodeMetaField) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Field
			Private bool
		}))(obj)).Field).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Field", err))
	}
	{
		p := &(*(*(struct {
			Field
			Private bool
		}))(obj)).Private
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *MinimapType) serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *MinimapType) deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *Param1Type) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *Param1Type) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *Param2Type) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *Param2Type) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *DrawType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *DrawType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *TileDef) serialize(w io.Writer) {
	{
		local364 := uint8(6)
		{
			x := local364
			write8(w, uint8(x))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Texture
			Anim  TileAnim
			Flags TileFlags

			//mt:if %s.Flags&TileColor != 0
			R, G, B uint8

			//mt:if %s.Flags&TileScale != 0
			Scale uint8

			//mt:if %s.Flags&TileAlign != 0
			Align AlignType
		}))(obj)).Texture).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Texture
			Anim  TileAnim
			Flags TileFlags

			//mt:if %s.Flags&TileColor != 0
			R, G, B uint8

			//mt:if %s.Flags&TileScale != 0
			Scale uint8

			//mt:if %s.Flags&TileAlign != 0
			Align AlignType
		}))(obj)).Anim).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.TileAnim", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Texture
			Anim  TileAnim
			Flags TileFlags

			//mt:if %s.Flags&TileColor != 0
			R, G, B uint8

			//mt:if %s.Flags&TileScale != 0
			Scale uint8

			//mt:if %s.Flags&TileAlign != 0
			Align AlignType
		}))(obj)).Flags).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.TileFlags", err))
	}
	if (*(*(struct {
		Texture
		Anim  TileAnim
		Flags TileFlags

		//mt:if %s.Flags&TileColor != 0
		R, G, B uint8

		//mt:if %s.Flags&TileScale != 0
		Scale uint8

		//mt:if %s.Flags&TileAlign != 0
		Align AlignType
	}))(obj)).Flags&TileColor != 0 {
		{
			x := (*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).R
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).G
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).B
			write8(w, uint8(x))
		}
	}
	if (*(*(struct {
		Texture
		Anim  TileAnim
		Flags TileFlags

		//mt:if %s.Flags&TileColor != 0
		R, G, B uint8

		//mt:if %s.Flags&TileScale != 0
		Scale uint8

		//mt:if %s.Flags&TileAlign != 0
		Align AlignType
	}))(obj)).Flags&TileScale != 0 {
		{
			x := (*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).Scale
			write8(w, uint8(x))
		}
	}
	if (*(*(struct {
		Texture
		Anim  TileAnim
		Flags TileFlags

		//mt:if %s.Flags&TileColor != 0
		R, G, B uint8

		//mt:if %s.Flags&TileScale != 0
		Scale uint8

		//mt:if %s.Flags&TileAlign != 0
		Align AlignType
	}))(obj)).Flags&TileAlign != 0 {
		if err := pcall(func() {
			((*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).Align).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AlignType", err))
		}
	}
}

func (obj *TileDef) deserialize(r io.Reader) {
	{
		var local365 uint8
		{
			p := &local365
			*p = read8(r)
		}
		if local365 != (6) {
			chk(fmt.Errorf("const %v: %v", 6, local365))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Texture
			Anim  TileAnim
			Flags TileFlags

			//mt:if %s.Flags&TileColor != 0
			R, G, B uint8

			//mt:if %s.Flags&TileScale != 0
			Scale uint8

			//mt:if %s.Flags&TileAlign != 0
			Align AlignType
		}))(obj)).Texture).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Texture
			Anim  TileAnim
			Flags TileFlags

			//mt:if %s.Flags&TileColor != 0
			R, G, B uint8

			//mt:if %s.Flags&TileScale != 0
			Scale uint8

			//mt:if %s.Flags&TileAlign != 0
			Align AlignType
		}))(obj)).Anim).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.TileAnim", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Texture
			Anim  TileAnim
			Flags TileFlags

			//mt:if %s.Flags&TileColor != 0
			R, G, B uint8

			//mt:if %s.Flags&TileScale != 0
			Scale uint8

			//mt:if %s.Flags&TileAlign != 0
			Align AlignType
		}))(obj)).Flags).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.TileFlags", err))
	}
	if (*(*(struct {
		Texture
		Anim  TileAnim
		Flags TileFlags

		//mt:if %s.Flags&TileColor != 0
		R, G, B uint8

		//mt:if %s.Flags&TileScale != 0
		Scale uint8

		//mt:if %s.Flags&TileAlign != 0
		Align AlignType
	}))(obj)).Flags&TileColor != 0 {
		{
			p := &(*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).R
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).G
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).B
			*p = read8(r)
		}
	}
	if (*(*(struct {
		Texture
		Anim  TileAnim
		Flags TileFlags

		//mt:if %s.Flags&TileColor != 0
		R, G, B uint8

		//mt:if %s.Flags&TileScale != 0
		Scale uint8

		//mt:if %s.Flags&TileAlign != 0
		Align AlignType
	}))(obj)).Flags&TileScale != 0 {
		{
			p := &(*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).Scale
			*p = read8(r)
		}
	}
	if (*(*(struct {
		Texture
		Anim  TileAnim
		Flags TileFlags

		//mt:if %s.Flags&TileColor != 0
		R, G, B uint8

		//mt:if %s.Flags&TileScale != 0
		Scale uint8

		//mt:if %s.Flags&TileAlign != 0
		Align AlignType
	}))(obj)).Flags&TileAlign != 0 {
		if err := pcall(func() {
			((*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).Align).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.AlignType", err))
		}
	}
}

func (obj *WaveType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *WaveType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *LiquidType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *LiquidType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *NodeBox) serialize(w io.Writer) {
	{
		local366 := uint8(6)
		{
			x := local366
			write8(w, uint8(x))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).Type).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.NodeBoxType", err))
	}
	if !((*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type < maxBox) {
		chk(errors.New("assertion failed: %s.Type < maxBox"))
	}
	if (*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type == MountedBox {
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).WallTop).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Box", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).WallBot).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Box", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).WallSides).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Box", err))
		}
	}
	if t := (*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type; t == FixedBox || t == LeveledBox || t == ConnectedBox {
		if len(((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).Fixed)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).Fixed)))
			write16(w, uint16(x))
		}
		for local367 := range (*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).Fixed {
			if err := pcall(func() {
				(((*(*(struct {
					Type NodeBoxType

					//mt:if %s.Type == MountedBox
					WallTop, WallBot, WallSides Box

					//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
					Fixed []Box

					//mt:if %s.Type == ConnectedBox
					ConnDirs, DiscoDirs  DirBoxes
					DiscoAll, DiscoSides []Box
				}))(obj)).Fixed)[local367]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Box", err))
			}
		}
	}
	if (*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type == ConnectedBox {
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).ConnDirs).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.DirBoxes", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).DiscoDirs).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.DirBoxes", err))
		}
		if len(((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoAll)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).DiscoAll)))
			write16(w, uint16(x))
		}
		for local368 := range (*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoAll {
			if err := pcall(func() {
				(((*(*(struct {
					Type NodeBoxType

					//mt:if %s.Type == MountedBox
					WallTop, WallBot, WallSides Box

					//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
					Fixed []Box

					//mt:if %s.Type == ConnectedBox
					ConnDirs, DiscoDirs  DirBoxes
					DiscoAll, DiscoSides []Box
				}))(obj)).DiscoAll)[local368]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Box", err))
			}
		}
		if len(((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoSides)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).DiscoSides)))
			write16(w, uint16(x))
		}
		for local369 := range (*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoSides {
			if err := pcall(func() {
				(((*(*(struct {
					Type NodeBoxType

					//mt:if %s.Type == MountedBox
					WallTop, WallBot, WallSides Box

					//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
					Fixed []Box

					//mt:if %s.Type == ConnectedBox
					ConnDirs, DiscoDirs  DirBoxes
					DiscoAll, DiscoSides []Box
				}))(obj)).DiscoSides)[local369]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Box", err))
			}
		}
	}
}

func (obj *NodeBox) deserialize(r io.Reader) {
	{
		var local370 uint8
		{
			p := &local370
			*p = read8(r)
		}
		if local370 != (6) {
			chk(fmt.Errorf("const %v: %v", 6, local370))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).Type).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.NodeBoxType", err))
	}
	if !((*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type < maxBox) {
		chk(errors.New("assertion failed: %s.Type < maxBox"))
	}
	if (*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type == MountedBox {
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).WallTop).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Box", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).WallBot).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Box", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).WallSides).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Box", err))
		}
	}
	if t := (*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type; t == FixedBox || t == LeveledBox || t == ConnectedBox {
		var local371 uint16
		{
			p := &local371
			*p = read16(r)
		}
		((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).Fixed) = make([]Box, local371)
		for local372 := range (*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).Fixed {
			if err := pcall(func() {
				(((*(*(struct {
					Type NodeBoxType

					//mt:if %s.Type == MountedBox
					WallTop, WallBot, WallSides Box

					//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
					Fixed []Box

					//mt:if %s.Type == ConnectedBox
					ConnDirs, DiscoDirs  DirBoxes
					DiscoAll, DiscoSides []Box
				}))(obj)).Fixed)[local372]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Box", err))
			}
		}
	}
	if (*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type == ConnectedBox {
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).ConnDirs).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.DirBoxes", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).DiscoDirs).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.DirBoxes", err))
		}
		var local373 uint16
		{
			p := &local373
			*p = read16(r)
		}
		((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoAll) = make([]Box, local373)
		for local374 := range (*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoAll {
			if err := pcall(func() {
				(((*(*(struct {
					Type NodeBoxType

					//mt:if %s.Type == MountedBox
					WallTop, WallBot, WallSides Box

					//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
					Fixed []Box

					//mt:if %s.Type == ConnectedBox
					ConnDirs, DiscoDirs  DirBoxes
					DiscoAll, DiscoSides []Box
				}))(obj)).DiscoAll)[local374]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Box", err))
			}
		}
		var local375 uint16
		{
			p := &local375
			*p = read16(r)
		}
		((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoSides) = make([]Box, local375)
		for local376 := range (*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoSides {
			if err := pcall(func() {
				(((*(*(struct {
					Type NodeBoxType

					//mt:if %s.Type == MountedBox
					WallTop, WallBot, WallSides Box

					//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
					Fixed []Box

					//mt:if %s.Type == ConnectedBox
					ConnDirs, DiscoDirs  DirBoxes
					DiscoAll, DiscoSides []Box
				}))(obj)).DiscoSides)[local376]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Box", err))
			}
		}
	}
}

func (obj *SoundDef) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Name              string
		Gain, Pitch, Fade float32
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Name))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Gain
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Pitch
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Fade
		write32(w, math.Float32bits(x))
	}
}

func (obj *SoundDef) deserialize(r io.Reader) {
	var local377 []uint8
	var local378 uint16
	{
		p := &local378
		*p = read16(r)
	}
	(local377) = make([]uint8, local378)
	{
		_, err := io.ReadFull(r, (local377)[:])
		chk(err)
	}
	((*(*(struct {
		Name              string
		Gain, Pitch, Fade float32
	}))(obj)).Name) = string(local377)
	{
		p := &(*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Gain
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Pitch
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Fade
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *AlphaUse) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *AlphaUse) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *Keys) serialize(w io.Writer) {
	{
		x := *(*(uint32))(obj)
		write32(w, uint32(x))
	}
}

func (obj *Keys) deserialize(r io.Reader) {
	{
		p := &*(*(uint32))(obj)
		*p = read32(r)
	}
}

func (obj *MapBlkFlags) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *MapBlkFlags) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *LitFromBlks) serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *LitFromBlks) deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *ItemType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *ItemType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *ToolCaps) serialize(w io.Writer) {
	if _ = (*(*(struct {
		//mt:if _ = %s; false
		NonNil bool

		AttackCooldown float32
		MaxDropLvl     int16

		//mt:len32
		GroupCaps []ToolGroupCaps

		//mt:len32
		DmgGroups []Group

		AttackUses uint16
	}))(obj)); false {
		{
			x := (*(*(struct {
				//mt:if _ = %s; false
				NonNil bool

				AttackCooldown float32
				MaxDropLvl     int16

				//mt:len32
				GroupCaps []ToolGroupCaps

				//mt:len32
				DmgGroups []Group

				AttackUses uint16
			}))(obj)).NonNil
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
	}
	{
		ow := w
		w := new(bytes.Buffer)
		/*
		   if r.N > 0 { (*(*(struct {
		   	//mt:if _ = %s; false
		   	NonNil	bool

		   	AttackCooldown	float32
		   	MaxDropLvl	int16

		   	//mt:len32
		   	GroupCaps	[]ToolGroupCaps

		   	//mt:len32
		   	DmgGroups	[]Group

		   	AttackUses	uint16
		   }))(obj)).NonNil = true}; /**/{
			if (*(*(struct {
				//mt:if _ = %s; false
				NonNil bool

				AttackCooldown float32
				MaxDropLvl     int16

				//mt:len32
				GroupCaps []ToolGroupCaps

				//mt:len32
				DmgGroups []Group

				AttackUses uint16
			}))(obj)).NonNil {
				{
					local379 := uint8(5)
					{
						x := local379
						write8(w, uint8(x))
					}
				}
				{
					x := (*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCaps

						//mt:len32
						DmgGroups []Group

						AttackUses uint16
					}))(obj)).AttackCooldown
					write32(w, math.Float32bits(x))
				}
				{
					x := (*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCaps

						//mt:len32
						DmgGroups []Group

						AttackUses uint16
					}))(obj)).MaxDropLvl
					write16(w, uint16(x))
				}
				if len(((*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCaps

					//mt:len32
					DmgGroups []Group

					AttackUses uint16
				}))(obj)).GroupCaps)) > math.MaxUint32 {
					chk(ErrTooLong)
				}
				{
					x := uint32(len(((*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCaps

						//mt:len32
						DmgGroups []Group

						AttackUses uint16
					}))(obj)).GroupCaps)))
					write32(w, uint32(x))
				}
				for local380 := range (*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCaps

					//mt:len32
					DmgGroups []Group

					AttackUses uint16
				}))(obj)).GroupCaps {
					if err := pcall(func() {
						(((*(*(struct {
							//mt:if _ = %s; false
							NonNil bool

							AttackCooldown float32
							MaxDropLvl     int16

							//mt:len32
							GroupCaps []ToolGroupCaps

							//mt:len32
							DmgGroups []Group

							AttackUses uint16
						}))(obj)).GroupCaps)[local380]).serialize(w)
					}); err != nil {
						if err == io.EOF {
							chk(io.EOF)
						}
						chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.ToolGroupCaps", err))
					}
				}
				if len(((*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCaps

					//mt:len32
					DmgGroups []Group

					AttackUses uint16
				}))(obj)).DmgGroups)) > math.MaxUint32 {
					chk(ErrTooLong)
				}
				{
					x := uint32(len(((*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCaps

						//mt:len32
						DmgGroups []Group

						AttackUses uint16
					}))(obj)).DmgGroups)))
					write32(w, uint32(x))
				}
				for local381 := range (*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCaps

					//mt:len32
					DmgGroups []Group

					AttackUses uint16
				}))(obj)).DmgGroups {
					if err := pcall(func() {
						(((*(*(struct {
							//mt:if _ = %s; false
							NonNil bool

							AttackCooldown float32
							MaxDropLvl     int16

							//mt:len32
							GroupCaps []ToolGroupCaps

							//mt:len32
							DmgGroups []Group

							AttackUses uint16
						}))(obj)).DmgGroups)[local381]).serialize(w)
					}); err != nil {
						if err == io.EOF {
							chk(io.EOF)
						}
						chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Group", err))
					}
				}
				{
					x := (*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCaps

						//mt:len32
						DmgGroups []Group

						AttackUses uint16
					}))(obj)).AttackUses
					write16(w, uint16(x))
				}
			}
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint16 {
				chk(ErrTooLong)
			}
			{
				x := uint16(len((buf.Bytes())))
				write16(w, uint16(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *ToolCaps) deserialize(r io.Reader) {
	if _ = (*(*(struct {
		//mt:if _ = %s; false
		NonNil bool

		AttackCooldown float32
		MaxDropLvl     int16

		//mt:len32
		GroupCaps []ToolGroupCaps

		//mt:len32
		DmgGroups []Group

		AttackUses uint16
	}))(obj)); false {
		{
			p := &(*(*(struct {
				//mt:if _ = %s; false
				NonNil bool

				AttackCooldown float32
				MaxDropLvl     int16

				//mt:len32
				GroupCaps []ToolGroupCaps

				//mt:len32
				DmgGroups []Group

				AttackUses uint16
			}))(obj)).NonNil
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
	}
	{
		var n uint16
		{
			p := &n
			*p = read16(r)
		}
		r := &io.LimitedReader{r, int64(n)}
		if r.N > 0 {
			(*(*(struct {
				//mt:if _ = %s; false
				NonNil bool

				AttackCooldown float32
				MaxDropLvl     int16

				//mt:len32
				GroupCaps []ToolGroupCaps

				//mt:len32
				DmgGroups []Group

				AttackUses uint16
			}))(obj)).NonNil = true
		} /**/
		{
			if (*(*(struct {
				//mt:if _ = %s; false
				NonNil bool

				AttackCooldown float32
				MaxDropLvl     int16

				//mt:len32
				GroupCaps []ToolGroupCaps

				//mt:len32
				DmgGroups []Group

				AttackUses uint16
			}))(obj)).NonNil {
				{
					var local382 uint8
					{
						p := &local382
						*p = read8(r)
					}
					if local382 != (5) {
						chk(fmt.Errorf("const %v: %v", 5, local382))
					}
				}
				{
					p := &(*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCaps

						//mt:len32
						DmgGroups []Group

						AttackUses uint16
					}))(obj)).AttackCooldown
					*p = math.Float32frombits(read32(r))
				}
				{
					p := &(*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCaps

						//mt:len32
						DmgGroups []Group

						AttackUses uint16
					}))(obj)).MaxDropLvl
					*p = int16(read16(r))
				}
				var local383 uint32
				{
					p := &local383
					*p = read32(r)
				}
				((*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCaps

					//mt:len32
					DmgGroups []Group

					AttackUses uint16
				}))(obj)).GroupCaps) = make([]ToolGroupCaps, local383)
				for local384 := range (*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCaps

					//mt:len32
					DmgGroups []Group

					AttackUses uint16
				}))(obj)).GroupCaps {
					if err := pcall(func() {
						(((*(*(struct {
							//mt:if _ = %s; false
							NonNil bool

							AttackCooldown float32
							MaxDropLvl     int16

							//mt:len32
							GroupCaps []ToolGroupCaps

							//mt:len32
							DmgGroups []Group

							AttackUses uint16
						}))(obj)).GroupCaps)[local384]).deserialize(r)
					}); err != nil {
						if err == io.EOF {
							chk(io.EOF)
						}
						chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.ToolGroupCaps", err))
					}
				}
				var local385 uint32
				{
					p := &local385
					*p = read32(r)
				}
				((*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCaps

					//mt:len32
					DmgGroups []Group

					AttackUses uint16
				}))(obj)).DmgGroups) = make([]Group, local385)
				for local386 := range (*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCaps

					//mt:len32
					DmgGroups []Group

					AttackUses uint16
				}))(obj)).DmgGroups {
					if err := pcall(func() {
						(((*(*(struct {
							//mt:if _ = %s; false
							NonNil bool

							AttackCooldown float32
							MaxDropLvl     int16

							//mt:len32
							GroupCaps []ToolGroupCaps

							//mt:len32
							DmgGroups []Group

							AttackUses uint16
						}))(obj)).DmgGroups)[local386]).deserialize(r)
					}); err != nil {
						if err == io.EOF {
							chk(io.EOF)
						}
						chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Group", err))
					}
				}
				{
					p := &(*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCaps

						//mt:len32
						DmgGroups []Group

						AttackUses uint16
					}))(obj)).AttackUses
					*p = read16(r)
				}
			}
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *AnimType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *AnimType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *Box) serialize(w io.Writer) {
	for local387 := range *(*([2]Vec))(obj) {
		if err := pcall(func() {
			((*(*([2]Vec))(obj))[local387]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Vec", err))
		}
	}
}

func (obj *Box) deserialize(r io.Reader) {
	for local388 := range *(*([2]Vec))(obj) {
		if err := pcall(func() {
			((*(*([2]Vec))(obj))[local388]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Vec", err))
		}
	}
}

func (obj *TileFlags) serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *TileFlags) deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *AlignType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *AlignType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *NodeBoxType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *NodeBoxType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *DirBoxes) serialize(w io.Writer) {
	if len(((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Top)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Top, Bot                 []Box
			Front, Left, Back, Right []Box
		}))(obj)).Top)))
		write16(w, uint16(x))
	}
	for local389 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Top {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Top)[local389]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Box", err))
		}
	}
	if len(((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Bot)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Top, Bot                 []Box
			Front, Left, Back, Right []Box
		}))(obj)).Bot)))
		write16(w, uint16(x))
	}
	for local390 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Bot {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Bot)[local390]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Box", err))
		}
	}
	if len(((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Front)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Top, Bot                 []Box
			Front, Left, Back, Right []Box
		}))(obj)).Front)))
		write16(w, uint16(x))
	}
	for local391 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Front {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Front)[local391]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Box", err))
		}
	}
	if len(((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Left)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Top, Bot                 []Box
			Front, Left, Back, Right []Box
		}))(obj)).Left)))
		write16(w, uint16(x))
	}
	for local392 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Left {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Left)[local392]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Box", err))
		}
	}
	if len(((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Back)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Top, Bot                 []Box
			Front, Left, Back, Right []Box
		}))(obj)).Back)))
		write16(w, uint16(x))
	}
	for local393 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Back {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Back)[local393]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Box", err))
		}
	}
	if len(((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Right)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Top, Bot                 []Box
			Front, Left, Back, Right []Box
		}))(obj)).Right)))
		write16(w, uint16(x))
	}
	for local394 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Right {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Right)[local394]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Box", err))
		}
	}
}

func (obj *DirBoxes) deserialize(r io.Reader) {
	var local395 uint16
	{
		p := &local395
		*p = read16(r)
	}
	((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Top) = make([]Box, local395)
	for local396 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Top {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Top)[local396]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Box", err))
		}
	}
	var local397 uint16
	{
		p := &local397
		*p = read16(r)
	}
	((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Bot) = make([]Box, local397)
	for local398 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Bot {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Bot)[local398]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Box", err))
		}
	}
	var local399 uint16
	{
		p := &local399
		*p = read16(r)
	}
	((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Front) = make([]Box, local399)
	for local400 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Front {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Front)[local400]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Box", err))
		}
	}
	var local401 uint16
	{
		p := &local401
		*p = read16(r)
	}
	((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Left) = make([]Box, local401)
	for local402 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Left {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Left)[local402]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Box", err))
		}
	}
	var local403 uint16
	{
		p := &local403
		*p = read16(r)
	}
	((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Back) = make([]Box, local403)
	for local404 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Back {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Back)[local404]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Box", err))
		}
	}
	var local405 uint16
	{
		p := &local405
		*p = read16(r)
	}
	((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Right) = make([]Box, local405)
	for local406 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Right {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Right)[local406]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.Box", err))
		}
	}
}

func (obj *ToolGroupCaps) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Name   string
		Uses   int16
		MaxLvl int16

		//mt:len32
		Times []DigTime
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Name   string
			Uses   int16
			MaxLvl int16

			//mt:len32
			Times []DigTime
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name   string
			Uses   int16
			MaxLvl int16

			//mt:len32
			Times []DigTime
		}))(obj)).Name))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Name   string
			Uses   int16
			MaxLvl int16

			//mt:len32
			Times []DigTime
		}))(obj)).Uses
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			Name   string
			Uses   int16
			MaxLvl int16

			//mt:len32
			Times []DigTime
		}))(obj)).MaxLvl
		write16(w, uint16(x))
	}
	if len(((*(*(struct {
		Name   string
		Uses   int16
		MaxLvl int16

		//mt:len32
		Times []DigTime
	}))(obj)).Times)) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(((*(*(struct {
			Name   string
			Uses   int16
			MaxLvl int16

			//mt:len32
			Times []DigTime
		}))(obj)).Times)))
		write32(w, uint32(x))
	}
	for local407 := range (*(*(struct {
		Name   string
		Uses   int16
		MaxLvl int16

		//mt:len32
		Times []DigTime
	}))(obj)).Times {
		if err := pcall(func() {
			(((*(*(struct {
				Name   string
				Uses   int16
				MaxLvl int16

				//mt:len32
				Times []DigTime
			}))(obj)).Times)[local407]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.DigTime", err))
		}
	}
}

func (obj *ToolGroupCaps) deserialize(r io.Reader) {
	var local408 []uint8
	var local409 uint16
	{
		p := &local409
		*p = read16(r)
	}
	(local408) = make([]uint8, local409)
	{
		_, err := io.ReadFull(r, (local408)[:])
		chk(err)
	}
	((*(*(struct {
		Name   string
		Uses   int16
		MaxLvl int16

		//mt:len32
		Times []DigTime
	}))(obj)).Name) = string(local408)
	{
		p := &(*(*(struct {
			Name   string
			Uses   int16
			MaxLvl int16

			//mt:len32
			Times []DigTime
		}))(obj)).Uses
		*p = int16(read16(r))
	}
	{
		p := &(*(*(struct {
			Name   string
			Uses   int16
			MaxLvl int16

			//mt:len32
			Times []DigTime
		}))(obj)).MaxLvl
		*p = int16(read16(r))
	}
	var local410 uint32
	{
		p := &local410
		*p = read32(r)
	}
	((*(*(struct {
		Name   string
		Uses   int16
		MaxLvl int16

		//mt:len32
		Times []DigTime
	}))(obj)).Times) = make([]DigTime, local410)
	for local411 := range (*(*(struct {
		Name   string
		Uses   int16
		MaxLvl int16

		//mt:len32
		Times []DigTime
	}))(obj)).Times {
		if err := pcall(func() {
			(((*(*(struct {
				Name   string
				Uses   int16
				MaxLvl int16

				//mt:len32
				Times []DigTime
			}))(obj)).Times)[local411]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/anon55555/mt.DigTime", err))
		}
	}
}

func (obj *DigTime) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Rating int16
			Time   float32
		}))(obj)).Rating
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			Rating int16
			Time   float32
		}))(obj)).Time
		write32(w, math.Float32bits(x))
	}
}

func (obj *DigTime) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Rating int16
			Time   float32
		}))(obj)).Rating
		*p = int16(read16(r))
	}
	{
		p := &(*(*(struct {
			Rating int16
			Time   float32
		}))(obj)).Time
		*p = math.Float32frombits(read32(r))
	}
}
